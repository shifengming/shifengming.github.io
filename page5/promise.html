<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>promise | ming的个人网站</title>
    <meta name="description" content="Welcome to come to my blog">
    <meta name="generator" content="VuePress 1.3.0">
    
    
    <link rel="preload" href="/assets/css/0.styles.70f2d267.css" as="style"><link rel="preload" href="/assets/js/app.f3f0b164.js" as="script"><link rel="preload" href="/assets/js/2.284f78c8.js" as="script"><link rel="preload" href="/assets/js/33.bd99df5c.js" as="script"><link rel="prefetch" href="/assets/js/10.d3bd6822.js"><link rel="prefetch" href="/assets/js/11.7be908fe.js"><link rel="prefetch" href="/assets/js/12.71222861.js"><link rel="prefetch" href="/assets/js/13.0e9f2f34.js"><link rel="prefetch" href="/assets/js/14.70e31408.js"><link rel="prefetch" href="/assets/js/15.8e83af5f.js"><link rel="prefetch" href="/assets/js/16.3f82f6aa.js"><link rel="prefetch" href="/assets/js/17.9c893c24.js"><link rel="prefetch" href="/assets/js/18.8ce12f88.js"><link rel="prefetch" href="/assets/js/19.4539c1e6.js"><link rel="prefetch" href="/assets/js/20.8d6b15a2.js"><link rel="prefetch" href="/assets/js/21.aa90be3e.js"><link rel="prefetch" href="/assets/js/22.0741e8cf.js"><link rel="prefetch" href="/assets/js/23.26e38199.js"><link rel="prefetch" href="/assets/js/24.437832b0.js"><link rel="prefetch" href="/assets/js/25.3ac7a3f9.js"><link rel="prefetch" href="/assets/js/26.f3036c64.js"><link rel="prefetch" href="/assets/js/27.85d3ca2e.js"><link rel="prefetch" href="/assets/js/28.f59e28e7.js"><link rel="prefetch" href="/assets/js/29.74627ca0.js"><link rel="prefetch" href="/assets/js/3.c17543fc.js"><link rel="prefetch" href="/assets/js/30.7b42eae2.js"><link rel="prefetch" href="/assets/js/31.9c88f4b6.js"><link rel="prefetch" href="/assets/js/32.3302434b.js"><link rel="prefetch" href="/assets/js/34.a20acac1.js"><link rel="prefetch" href="/assets/js/35.d2d4f756.js"><link rel="prefetch" href="/assets/js/36.18286c43.js"><link rel="prefetch" href="/assets/js/37.84831a8a.js"><link rel="prefetch" href="/assets/js/38.ce143c7c.js"><link rel="prefetch" href="/assets/js/39.11e44bd7.js"><link rel="prefetch" href="/assets/js/4.24ba765a.js"><link rel="prefetch" href="/assets/js/40.cb8f8018.js"><link rel="prefetch" href="/assets/js/41.f6a28df9.js"><link rel="prefetch" href="/assets/js/42.fbd48b3c.js"><link rel="prefetch" href="/assets/js/43.131d6d97.js"><link rel="prefetch" href="/assets/js/44.2c119204.js"><link rel="prefetch" href="/assets/js/45.198a5b50.js"><link rel="prefetch" href="/assets/js/46.c2f0e139.js"><link rel="prefetch" href="/assets/js/47.71dfa535.js"><link rel="prefetch" href="/assets/js/48.cb8ad619.js"><link rel="prefetch" href="/assets/js/49.cbeee829.js"><link rel="prefetch" href="/assets/js/5.e87ba801.js"><link rel="prefetch" href="/assets/js/50.ff87b9b9.js"><link rel="prefetch" href="/assets/js/51.8943f310.js"><link rel="prefetch" href="/assets/js/52.f08a077e.js"><link rel="prefetch" href="/assets/js/53.5b096969.js"><link rel="prefetch" href="/assets/js/54.39e8487d.js"><link rel="prefetch" href="/assets/js/55.581e549d.js"><link rel="prefetch" href="/assets/js/56.d60cbfa0.js"><link rel="prefetch" href="/assets/js/6.b35a0751.js"><link rel="prefetch" href="/assets/js/7.aa04d747.js"><link rel="prefetch" href="/assets/js/8.2805aa08.js"><link rel="prefetch" href="/assets/js/9.2159abe2.js">
    <link rel="stylesheet" href="/assets/css/0.styles.70f2d267.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">ming的个人网站</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/page5/page1/" class="nav-link">
  前端技术
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="个人文章" class="dropdown-title"><span class="title">个人文章</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://segmentfault.com/u/helloxiaoming" target="_blank" rel="noopener noreferrer" class="nav-link external">
  segmentfault
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <a href="https://github.com/shifengming" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/page5/page1/" class="nav-link">
  前端技术
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="个人文章" class="dropdown-title"><span class="title">个人文章</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://segmentfault.com/u/helloxiaoming" target="_blank" rel="noopener noreferrer" class="nav-link external">
  segmentfault
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <a href="https://github.com/shifengming" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTML</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>CSS3</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JQuery</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>ES6</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/page5/深入解读es6.html" class="sidebar-link">深入解读es6</a></li><li><a href="/page5/promise.html" class="active sidebar-link">promise</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/page5/promise.html#promise在异步编程中的核心应用" class="sidebar-link">Promise在异步编程中的核心应用</a></li><li class="sidebar-sub-header"><a href="/page5/promise.html#简版的promise" class="sidebar-link">简版的Promise</a></li><li class="sidebar-sub-header"><a href="/page5/promise.html#完整版的promise" class="sidebar-link">完整版的Promise</a></li><li class="sidebar-sub-header"><a href="/page5/promise.html#扩展" class="sidebar-link">扩展</a></li><li class="sidebar-sub-header"><a href="/page5/promise.html#promise常见的面试题" class="sidebar-link">Promise常见的面试题</a></li><li class="sidebar-sub-header"><a href="/page5/promise.html#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/page5/promise对象的使用.html" class="sidebar-link">promise对象的使用</a></li><li><a href="/page5/题目.html" class="sidebar-link">题目</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>React</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>小程序</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Github</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Http请求</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Ajax</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Webpack</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>项目</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="promise"><a href="#promise" class="header-anchor">#</a> promise</h1> <h2 id="promise在异步编程中的核心应用"><a href="#promise在异步编程中的核心应用" class="header-anchor">#</a> Promise在异步编程中的核心应用</h2> <p>在使用 <code>Promise</code> 解决工作中常见异步问题时，首先得知道其有哪些优缺点：</p> <blockquote><p>Promise 有哪些优缺点：</p></blockquote> <ul><li>优点
<ol><li>可以解决异步嵌套的问题（回调地狱）</li> <li>可以解决异步并发的问题</li> <li>代码更清晰、链式调用等等</li></ol></li> <li>缺点
<ol><li><code>Promise</code> 本身也是基于回调的</li> <li><code>Promise</code> 无法终止，一创建立即执行，无法取消</li> <li>当状态为 <code>Pending</code> 时，无法得知代码进站在那个阶段（刚刚开始还是处理中）等等</li></ol></li></ul> <p><strong>注意</strong>：正因为有以上一些缺陷，<code>ES7</code> 中引入了异步终极解决方案 <code>asyns + await</code>！</p> <blockquote><p>Promise 常见应用（举一例）</p></blockquote> <ul><li><p>解决回调地狱</p> <p>例：很常见的需求：获取一个文件中的内容（其中，一个文件的内容为另一个文件的文件名）</p> <p>在不使用 <code>Promise</code> 之前，大多都是通过回调的方式完成的。但如果是多个文件的话，会照成两个很明显的不足：一是回调嵌套层数多、而是回调异常情况不能统一。若使用 <code>Promise</code> 可以很容易解决以上两种情况。</p> <p><img src="http://m.qpic.cn/psc?/V129bHJB4fgIUn/POwAobJtn54NCYlSXd4O2eCyWfELy3pTE0.4nUJQNCuomv61MJEjW5900zZMHxtN8TASN2M61uqqQYRcuZixrg!!/b&amp;bo=3gQmAwAAAAADB90!&amp;rf=viewer_4" alt=""><img src="http://m.qpic.cn/psc?/V129bHJB4fgIUn/POwAobJtn54NCYlSXd4O2T4XIQ9zV2Jcs*Ax1rqDam16n6uMc5enJPIQcZEifz88AjgUH0DRe5OkdhoU9CTgxQ!!/b&amp;bo=PwQ4BAAAAAADByU!&amp;rf=viewer_4" alt=""></p></li></ul> <p>通过以上例子，是不是觉得 <code>Promise</code> 的用法实在太简单了。接下来，我们将详细的分不同情况的实现一套符合 <code>Promise A+ 规范</code>的 <code>Promise</code>。</p> <h2 id="简版的promise"><a href="#简版的promise" class="header-anchor">#</a> 简版的Promise</h2> <blockquote><p>三种状态</p></blockquote> <ul><li><code>Pending</code>：等待态（初始状态）</li> <li><code>Fulfilled</code>：成功态</li> <li><code>Rejected</code>：失败态</li></ul> <p><strong>注意</strong>：状态只能从 <code>Pending</code> 等待态 变成 <code>Fulfilled</code> 成功态；或者从 <code>Pending</code> 等待态 变成  <code>Rejected</code> 失败态。并且状态一旦变成成功态或者失败态后就不能改变了。</p> <blockquote><p>执行器 - executor</p></blockquote> <p><code>Promise</code> 默认接受一个执行器 <code>executor</code> 作为参数，并且该执行器会默认执行。</p> <p>执行器 <code>executor</code> 默认接受两个参数：一个 <code>resolve</code> 成功的回调、一个 <code>reject</code> 失败的回调。</p> <p>接下来，我们从处理 <strong>同步</strong>、<strong>异步</strong>两种情况来完善简约版的 <code>Promise</code>。</p> <blockquote><p>核心函数 - then</p></blockquote> <p><code>then</code> 方法会接受两个参数：一个是成功时的 <code>onfulfilled</code>，一个是失败时的 <code>onrejected</code>。<strong>注意</strong>：<code>then</code> 的参数是可选的。</p> <h3 id="处理同步"><a href="#处理同步" class="header-anchor">#</a> 处理同步</h3> <p><img src="http://m.qpic.cn/psc?/V129bHJB4fgIUn/POwAobJtn54NCYlSXd4O2TK72h8B3RKVOOQmbTnqtzIFmSTIn6L.*VD1GqWn0r0RLxHW5KRcuOg4fK28epmu2g!!/b&amp;bo=OARhBQAAAAADB3o!&amp;rf=viewer_4" alt=""></p> <p><strong>注意</strong>：在执行器 <code>executor</code>在执行时，内部有可能报错，为了代码的健全性需要给执行器添加异常处理，报错相当于执行了失败态并将报错信息传递下去。</p> <blockquote><p>验证</p></blockquote> <ul><li><p>成功情况</p> <p><img src="http://m.qpic.cn/psc?/V129bHJB4fgIUn/POwAobJtn54NCYlSXd4O2ba.mvtibej1FBhbIZLNfn1b2Y1EScTseL6kkKmASwJiGxMaxUBG*9XRJXbgZqT90g!!/b&amp;bo=RwQ4BAAAAAADB10!&amp;rf=viewer_4" alt=""></p></li> <li><p>失败情况</p> <p><strong>注意</strong>：抛错也当成失败处理</p> <p><img src="http://m.qpic.cn/psc?/V129bHJB4fgIUn/POwAobJtn54NCYlSXd4O2WF4DOAM*Y0SgC2LCP4JFEvPb5mMItSHaraEyqd7rbA8ZB3*NAZhY3y5gxEZZsblzw!!/b&amp;bo=OARuBAAAAAADB3Q!&amp;rf=viewer_4" alt=""></p></li></ul> <p>以上代码逻辑支持基本功能，但回调函数中存在异步代码，以上的 <code>Promise</code> 就无法实现。请看下小节 <strong>处理异步</strong> 情况！</p> <h3 id="处理异步"><a href="#处理异步" class="header-anchor">#</a> 处理异步</h3> <p>若回调中存在异步代码，导致 <code>Promise</code> 实例的状态一直在 <code>Pending</code>。上节只处理了<code>Fulfilled</code> 成功和 <code>Rejected</code> 失败两种状态，故 <code>then</code> 方法还需添加状态为 <code>Pending</code> 的情况。</p> <p><img src="http://m.qpic.cn/psc?/V129bHJB4fgIUn/POwAobJtn54NCYlSXd4O2ZkhAKrEBzeVoP2W7oa6Rt.3Oww3qvO6*nf45TiN*EyyzRfwboIzra9sktS.b.KGdg!!/b&amp;bo=OARFBQAAAAADB14!&amp;rf=viewer_4" alt=""></p> <blockquote><p>验证</p></blockquote> <ul><li><p>添加异步代码情况</p> <p><img src="http://m.qpic.cn/psc?/V129bHJB4fgIUn/POwAobJtn54NCYlSXd4O2bxBC6T9nBWLAAp1zHRvPuutvr9T.JTEQsW9tnU8in4awNw2CAevj1wkVBfJtThNdg!!/b&amp;bo=VgT.AwAAAAADB40!&amp;rf=viewer_4" alt=""></p> <p>由于 <code>JS执行机制</code> ，当执行 <code>then</code> 时，此时 <code>Promise</code> 实例的状态还是 <code>Pending</code>，导致代码什么也没有输出。</p></li> <li><p>在then方法中添加  <code>Pending</code> 状态的情况</p> <p><img src="http://m.qpic.cn/psc?/V129bHJB4fgIUn/POwAobJtn54NCYlSXd4O2a0aWQ5oL5O*jPptcAWi3cpI1GXWRBGaXLA*owIcpkWG.tLO6mzbTNmf9PFvT9pP1g!!/b&amp;bo=RwQ4BAAAAAADB10!&amp;rf=viewer_4" alt=""></p> <p><strong>注意</strong>：在处理实例为 <code>pending</code> 时，运用到了 <strong>发布订阅模式</strong>。</p></li></ul> <h2 id="完整版的promise"><a href="#完整版的promise" class="header-anchor">#</a> 完整版的Promise</h2> <p>在编写完整版 <code>Promise</code> 前，先看下以下常见问题：</p> <ul><li>为什么要加定时器？</li> <li>为什么在处理异步情况的时候也要加try-catch？</li> <li>返回值 <code>x</code> 有几种情况？</li> <li>如何通过返回值 <code>x</code> 去推导 <code>promise2</code> 的状态？</li> <li>....</li></ul> <p>接下来，我们就一起揭开以上问题吧~~~</p> <h3 id="核心方法-then"><a href="#核心方法-then" class="header-anchor">#</a> 核心方法 - then</h3> <blockquote><p>then 方法传入成功和失败的回调函数，返回一个新的Promise对象</p></blockquote> <h4 id="then-的实现原理"><a href="#then-的实现原理" class="header-anchor">#</a> then 的实现原理</h4> <p>为了实现 <code>then</code> 方法的实现原理，我们从以下两点去考虑：</p> <blockquote><p>一、当前 <code>Promise</code> 的状态</p></blockquote> <p><code>Promise</code> 实例调用 <code>then</code> 方法时，此时当前 <code>Promise</code> 的状态有可能是成功态 <code>fulfilled</code>、有可能是失败态 <code>rejected</code>、也有可能是等待态 <code>pending</code>。故，需要从这三个状态去考虑<code>then</code>的实现原理：</p> <ol><li><p>状态为成功 <code>fulfilled</code></p> <p>由于 <code>then</code> 方法是异步执行，所以需要添加一个 <code>setTimout</code> 将成功的回调函数 <code>onfulfilled</code> 包裹起来，并且将成功的值 <code>value</code>传入。</p></li> <li><p>状态为失败 <code>rejected</code></p> <p>由于 <code>then</code> 方法是异步执行，所以需要添加一个 <code>setTimout</code> 将成功的回调函数 <code>onrejected</code> 包裹起来，并且将失败的原因 <code>reason</code>传入。</p></li> <li><p>状态为等待 <code>pending</code></p> <p>当状态为 <code>Pending</code> 时，此时需要将成功的回调函数 <code>onfulfilled</code> 和异步的回调函数<code>onrejected</code>  分别存放到对应的存放成功回调 <code>onResolvedCallbacks</code> 的数组中和存放失败回调 <code>onRejectedCallbacks</code> 的数组中。等待<code>状态</code>变为<code>成功态</code>或<code>者失败态</code>时，依次执行数组里的回调函数。</p></li></ol> <blockquote><p>二、执行 then 方法后返回新的 Promise</p></blockquote> <p>由于执行 <code>then</code> 方法，要返回一个新的 <code>Promise</code> 。不管当前 <code>Promise</code> 是哪一种状态执行后都会有一个返回值。为了可以实现<strong>链式调用</strong>，需要将该返回值传递下去。成功就 <code>resolve</code>让新的 <code>Promise</code> 状态为<code>成功态</code>，失败就 <code>reject</code>让新的 <code>Promise</code> 状态为<code>失败态</code>。</p> <p>在返回新的 <code>Promise</code> 时，需要考虑以下几点：</p> <ol><li>用户一上来就 <code>resolve</code> ，此时由于 <code>JS执行机制</code> 的影响，会出现新返回的 <code>Promise</code> 为 <code>undefined</code>。解决此问题，需要添加一个定时器<code>setTimeout</code>将<strong>当前上下文</strong>添加到<code>异步队列</code>中等<code>new Promise</code> 执行完后再执行逻辑。</li> <li>用户一上来就抛错，然而我们自己写的 <code>Promise</code> 中 <code>executor</code> 的异常处理只能捕获<strong>同步异常</strong>情况。此时，需要在处理异步的情况下也添加一个 <code>try - catch</code> 捕获异常。如果有异常的话，直接让新返回的 <code>promise</code> 直接 <code>reject</code>。</li></ol> <p><strong>注意</strong>：该返回值有几种情况，下小节我们会详解</p> <blockquote><p>三、判断返回值 <code>x</code> 去推导新返回的 <code>Promise</code> 的状态</p></blockquote> <p>若 <code>x</code> 是普通值就直接 <code>resolve</code>这个值；若 <code>x</code> 是 <code>Promise</code> 类型的就执行<code>.then</code>看结果是成功还是失败；若 <code>x</code> 是失败的 <code>Promise</code> 就执行 <code>reject</code>；通过这三种情况，我们编写一个公共的方法 - <code>resolvePromise</code> 来判断 <code>x</code> 和新的 <code>Promise</code> 的关系。</p> <p>在编写公共 <code>resolvePromise</code> 方法时， <strong>Promise A+要求的</strong>需要注意一下几点：</p> <ol><li><p><code>x</code> 的值不能和返回的 <code>promise</code> 一样，否则报错。<code>new TypeError('Chaining cycle detected for promise #&lt;Promise&gt;'</code>。</p></li> <li><p>需要编写一个功能方法 <code>isPromise</code> 来判断 <code>x</code> 的值是否是 <code>Promise</code> 类型。若是，则调用<code>.then</code>方法；若不是，则为普通值，调用 <code>promise2</code> 的 <code>resolve</code>方法，并把值传递下去。</p></li> <li><p>若 <code>x</code> 是 <code>Promise</code> 类型时，<code>x.then</code> 有可能报错。此时需要添加一个 <code>try-catch</code> 异常。用 <code>promise2</code> 的 <code>reject</code> 方法将错误信息抛出。</p></li> <li><p>若 <code>then</code> 属性是一个函数的话，就默认规定 <code>x</code> 是一个 <code>Promise</code> 类型；若 <code>then</code> 属性不是一个函数的话，就是一个普通对象，直接调用 <code>promise2</code> 的 <code>resolve</code> 方法并将值传入。</p></li> <li><p>通过 <code>then.call(x)</code> 是为了不用再次取 <code>then</code> 的值，防止取不到 <code>then</code>。并且将 <code>y</code> 作为成功回调的参数，<code>r</code> 作为 失败回调的参数。下一层可以获取到 <code>promise2</code>返回成功的 y<code>和失败的</code>r。只需要状态成功时调用 <code>promise2</code>的 <code>resolve</code>并将 <code>y</code>传入；状态失败时调用 <code>promise2</code>的 <code>reject</code> 并将 <code>r</code>传入。</p></li> <li><p>注意 <code>y</code> 有可能还是一个 <code>Promise</code>类型，此时需要<strong>递归</strong>调用 <code>resolvePromise</code> 方法直到 <code>y</code> 是一个普通值。</p></li></ol> <h3 id="核心方法-resolvepromise"><a href="#核心方法-resolvepromise" class="header-anchor">#</a> 核心方法 - resolvePromise</h3> <ul><li><p>判断对象是否是 Promise</p> <p><img src="http://m.qpic.cn/psc?/V129bHJB4fgIUn/POwAobJtn54NCYlSXd4O2aHVwEQ3yOdj5il1e5Jrjtnv7iDJHw89VG3a6zLotq5zCsIuRYH4YYiZ1qhnh*hy.g!!/b&amp;bo=1ga6AgAAAAADB0o!&amp;rf=viewer_4" alt=""></p></li> <li><p>完整版 Promise
<img src="http://m.qpic.cn/psc?/V129bHJB4fgIUn/POwAobJtn54NCYlSXd4O2fQOptfe.K6tmXhI7vEGqpDduFEbp2ttwTLDFdhTDqKNUgrTqpROUUc67aMwHtMlKA!!/b&amp;bo=OASJDQAAAAADB5o!&amp;rf=viewer_4" alt=""></p></li></ul> <h3 id="测试promise是否符合标准"><a href="#测试promise是否符合标准" class="header-anchor">#</a> 测试Promise是否符合标准</h3> <ul><li><p>安装测试Promise依赖包</p> <div class="language- extra-class"><pre class="language-text"><code>npm install promises-aplus-tests -g
</code></pre></div></li> <li><p>编写 - 延迟对象</p> <p><img src="http://m.qpic.cn/psc?/V129bHJB4fgIUn/POwAobJtn54NCYlSXd4O2W8S6mbrL4Kc.UKoFO5f4gCr3gLHutmmIe4zifjIWWwKopfg*o0ky4L2*tmCi3AvoQ!!/b&amp;bo=mgSWAgAAAAADByg!&amp;rf=viewer_4" alt=""></p></li> <li><p>执行验证</p> <div class="language- extra-class"><pre class="language-text"><code>promises-aplus-tests promise.js
</code></pre></div><p><img src="http://m.qpic.cn/psc?/V129bHJB4fgIUn/POwAobJtn54NCYlSXd4O2Vn6Fgc*VWcfDGC6gbHQchs9G1Z6UOtUZDDMMbPEErEOkZl.dZ2Fnv6Vyg8KQimUeg!!/b&amp;bo=TQQ4BAAAAAADB1c!&amp;rf=viewer_4" alt=""></p></li></ul> <h2 id="扩展"><a href="#扩展" class="header-anchor">#</a> 扩展</h2> <h3 id="promise-resolve"><a href="#promise-resolve" class="header-anchor">#</a> Promise.resolve</h3> <blockquote><p>Promise.resolve 的作用：返回一个 <code>fulfilled</code> 的 <code>Promise</code> 实例，或原始 <code>Promise</code> 实例。</p></blockquote> <p>在实现该功能前，我们需要了解 <code>Promise.resolve</code> 方法中参数的情况：</p> <ol><li>若参数为空，则返回一个状态为 <code>fulfilled</code> 的 <code>Promise</code> 实例</li> <li>若参数为 <code>Promise</code> 实例，则返回这个实例，不做修改</li> <li>若参数为普通值，则返回一个状态为 <code>fulfilled</code> 的 <code>Promise</code> 实例并且 <code>fulfilled</code> 响应函数会得到这个参数</li> <li>若参数为 <code>thenable</code> 对象, 立即执行它的 <code>.then()</code> 方法</li></ol> <p><strong>注意</strong>：对象里含有 <code>then</code> 方法就叫 <code>thenable</code> 对象。</p> <blockquote><p>resolve 的实现</p></blockquote> <p><img src="http://m.qpic.cn/psc?/V129bHJB4fgIUn/POwAobJtn54NCYlSXd4O2ZYKpYjBt3utT10*p*6wmFrkmSGABBEdcrzhdsJtsXVE.2M2vOb7Mr8KQQqkaF*hPw!!/b&amp;bo=6Aa2AwAAAAADB3k!&amp;rf=viewer_4" alt=""></p> <p>接下来，我们给不同的参数的例子来验证写的 <code>Promise.resolve</code> 是否符合预期。</p> <p><img src="http://m.qpic.cn/psc?/V129bHJB4fgIUn/POwAobJtn54NCYlSXd4O2eQkzY7X83VO1eRJTTYSJ9V5X5fBc4gtUD.8lmDL0sPHd.bwVsm5F3p.C8AswSeTlg!!/b&amp;bo=OATXBAAAAAADB80!&amp;rf=viewer_4" alt=""></p> <h3 id="promise-reject"><a href="#promise-reject" class="header-anchor">#</a> Promise.reject</h3> <blockquote><p>reject：返回一个状态为 <code>rejected</code> 的 <code>Promise</code> 实例</p></blockquote> <blockquote><p>reject 的实现</p></blockquote> <p><img src="http://m.qpic.cn/psc?/V129bHJB4fgIUn/POwAobJtn54NCYlSXd4O2WUNmgLoYaMho2p0.5*4G90wHkKsKdWEIpO69TQ6KW8SJhHsB2*g92IzI*f2SYlNCQ!!/b&amp;bo=*gTiAQAAAAADBzs!&amp;rf=viewer_4" alt=""></p> <p>接下来，我们给不同的参数的例子来验证写的 <code>Promise.reject</code> 是否符合预期。</p> <p><img src="http://m.qpic.cn/psc?/V129bHJB4fgIUn/POwAobJtn54NCYlSXd4O2c3mVrSVOny1rbHhx7V9v19PSHp07irD1nxL0vDOQaAsAiOg92BinT.2RRdmD4N40g!!/b&amp;bo=AgTeAgAAAAADB*g!&amp;rf=viewer_4" alt=""></p> <h3 id="promise-race"><a href="#promise-race" class="header-anchor">#</a> Promise.race</h3> <blockquote><p>race 的实现</p></blockquote> <p><img src="http://m.qpic.cn/psc?/V129bHJB4fgIUn/POwAobJtn54NCYlSXd4O2UZO*grNDxXMgpJ2heNI7dm9hYMv6l98jbpESOcCBpXWHelIx74YaZ9ITu7b.0jiiw!!/b&amp;bo=NAQCAwAAAAADBxM!&amp;rf=viewer_4" alt=""></p> <p><strong>注意</strong>：若数组里传的不是一个 <code>Promise</code> 对象，需要将其通过  <code>Promise.resolve</code>变成  <code>Promise</code></p> <p>接下来，我们给不同的参数的例子来验证写的 <code>Promise.race</code> 是否符合预期。</p> <p><img src="http://m.qpic.cn/psc?/V129bHJB4fgIUn/POwAobJtn54NCYlSXd4O2QlujtU2vOZlrZncq4nPBQP*kDSB0Q4pvGCjYhbVCAFuQWPBCfNTiyRbpcN1iRjJZw!!/b&amp;bo=ZgSSAwAAAAADB9E!&amp;rf=viewer_4" alt=""></p> <p><strong>注意</strong>：是谁最先完成，并且最先完成的成功就成功，失败就失败。</p> <p><img src="http://m.qpic.cn/psc?/V129bHJB4fgIUn/POwAobJtn54NCYlSXd4O2UOq3oPAVnbpxYy.xmYGbiEX1DSwtH4Y6wksf9ymz2yH1NjtRpXEF5*2uLJVLuX7mg!!/b&amp;bo=IgTaAwAAAAADB90!&amp;rf=viewer_4" alt=""></p> <h3 id="promise-all"><a href="#promise-all" class="header-anchor">#</a> Promise.all</h3> <blockquote><p>all：返回一个Promise,只有当所有的promise都成功才成功，否则只有一个失败就失败</p></blockquote> <p><strong>注意</strong>：若数组里传的不是一个 <code>Promise</code> 对象，需要将其通过  <code>Promise.resolve</code>变成  <code>Promise</code></p> <blockquote><p>all 的实现</p></blockquote> <p><img src="http://m.qpic.cn/psc?/V129bHJB4fgIUn/I4OEOPrz6D2aFnaB6dwLRWGOjvkBQMuFuLf83xoEGNsAP70*Sejzyhylxqa8Jh6gtUD6lcGZGlXS9Siaul3J.2iSrixEEhnt8KgiM2tjApk!/b&amp;bo=ygTaAwAAAAADJxU!&amp;rf=viewer_4" alt=""></p> <p>接下来，我们给不同的参数的例子来验证写的 <code>Promise.all</code> 是否符合预期。</p> <p><img src="http://m.qpic.cn/psc?/V129bHJB4fgIUn/POwAobJtn54NCYlSXd4O2dBNfjmp7s5LQmboq31wt1ypukN0QmTEvOpXj6lVcgddBJkN*9PnqcQlJRzC.u5R6A!!/b&amp;bo=*gS2AwAAAAADB20!&amp;rf=viewer_4" alt=""></p> <h3 id="promise-finally"><a href="#promise-finally" class="header-anchor">#</a> Promise.finally</h3> <blockquote><p>finally：最终的（无论成功或失败都会执行）</p></blockquote> <blockquote><p>finally 的实现</p></blockquote> <p><img src="http://m.qpic.cn/psc?/V129bHJB4fgIUn/POwAobJtn54NCYlSXd4O2YM1cJKvqaebAzLinJQbRyDndyhBFJpG5gbnqRtgKvVaf2jrvt0vwpGYvJBdAkX0yQ!!/b&amp;bo=ZgQCAwAAAAADB0E!&amp;rf=viewer_4" alt=""></p> <ul><li>高逼格代码实现 <code>finally</code></li></ul> <p><img src="http://m.qpic.cn/psc?/V129bHJB4fgIUn/POwAobJtn54NCYlSXd4O2ZSFAblo36nlJs4l.qgT.EPrAugTyyDm9Jt8Ifs49GDxzcV2qOz6rNyjpqwP19NJgw!!/b&amp;bo=IAVOAgAAAAADB0s!&amp;rf=viewer_4" alt=""></p> <p>接下来，我们给不同的参数的例子来验证写的 <code>Promise.finally</code> 是否符合预期。</p> <p><img src="http://m.qpic.cn/psc?/V129bHJB4fgIUn/POwAobJtn54NCYlSXd4O2eRLp5jVFAueSKCWOAC6dlReHYHNqkZTno0MJrZhwje4cESDHXsRm6xjvgHJLoNZpA!!/b&amp;bo=RwQ4BAAAAAADB10!&amp;rf=viewer_4" alt=""></p> <h3 id="promise-catch"><a href="#promise-catch" class="header-anchor">#</a> Promise.catch</h3> <blockquote><p>catch：执行失败的回调函数，返回一个新的Promise对象</p></blockquote> <p><code>Promise.prototype.catch</code> 方法是 <code>then(null/undefined, reject)</code> 的别名，两者效果一样。</p> <blockquote><p>catch 的实现</p></blockquote> <p><img src="http://m.qpic.cn/psc?/V129bHJB4fgIUn/POwAobJtn54NCYlSXd4O2RlxPuGXd.sZHEGlpXDCrJqDtwUkIbSHwIm5KKbicxutFrvjKIqAywIp398V22EACw!!/b&amp;bo=VgTiAQAAAAADB5M!&amp;rf=viewer_4" alt=""></p> <p>接下来，我们给不同的参数的例子来验证写的 <code>Promise.catch</code> 是否符合预期。</p> <p><img src="http://m.qpic.cn/psc?/V129bHJB4fgIUn/POwAobJtn54NCYlSXd4O2fflcyXLxN7fUKk8jWN6eXkwM6pkYDAJoPlSCzZZcOsXCCRrdJSNc*oXvGZIG8bp2A!!/b&amp;bo=8gMiBAAAAAADB*U!&amp;rf=viewer_4" alt=""></p> <p>以上一些扩展方法，其都会返回一个新的 <code>Promise</code>。然后通过其状态去执行相应的回调函数。下面通过几道有关 <code>Promise</code> 的面试题来检测我们对  <code>Promise</code> 的掌握程度。</p> <h2 id="promise常见的面试题"><a href="#promise常见的面试题" class="header-anchor">#</a> Promise常见的面试题</h2> <h3 id="题目一"><a href="#题目一" class="header-anchor">#</a> 题目一</h3> <blockquote><p>输出一下结果？</p></blockquote> <p><img src="http://m.qpic.cn/psc?/V129bHJB4fgIUn/POwAobJtn54NCYlSXd4O2UOEuAF2y87o2G5Ssxq5rhqwzgJBHZ9M8kMaZ9Xea1Lr0V25qs0H4azrR17dYh5ISQ!!/b&amp;bo=agPWBAAAAAADB5k!&amp;rf=viewer_4" alt=""></p> <p>详细的分析一下这题的解题思路，首先我们要知道<strong>宏任务</strong>、<strong>微任务</strong>、<strong>任务队列</strong>等概念：</p> <ol><li>由于``JS<code>执行机制，代码从上往下执行，先执行完同步任务再执行异步任务，将异步任务都存放对应的**任务队列**中。故，一轮输出：</code>1 <code>和</code>8`。下面分析下执行异步时的情况：</li> <li>当代码执行到  <code>setTimeout</code> 时，由于<code>setTimeout</code>是<strong>宏任务</strong>。故将 <code>2</code> 存放在<strong>宏任务队列</strong>中等待执行。<code>Promise</code> 相关等方法属于<strong>微任务</strong>，将值依次存放在<strong>微任务队列</strong>中等待执行。</li> <li>当代码执行到 <code>new Promise</code>调用 <code>.then</code> 方法时，由于回调函数中执行了 <code>resolve</code> 方法，代码会走成功的回调，并且 <code>resolve</code> 函数没有参数，所以成功的回调参数 <code>data</code> 没有值。故，输出：<code>3</code> 和 <code>undefined</code>。</li> <li>当代码执行到 <code>Promise.resolve</code> 时，直接走成功的回调，并且 <code>resolve</code> 中有参数，所以将这个参数作为成功的回调参数的 <code>data</code>。故，输出 <code>6</code>和 <code>5</code>。</li> <li>当第二轮<strong>微任务队列</strong>走完后，再走<strong>宏任务队列</strong>，故，第三轮输出：<code>2</code>。</li></ol> <p><strong>注意</strong>：做此题的技巧：① 先走完<code>同步</code>、② 再走<code>异步</code>，其中<code>异步方法</code>中先走<code>微任务</code>再走<code>宏任务</code>。</p> <h3 id="题目二"><a href="#题目二" class="header-anchor">#</a> 题目二</h3> <blockquote><p>输出一下结果？</p></blockquote> <p><img src="http://m.qpic.cn/psc?/V129bHJB4fgIUn/POwAobJtn54NCYlSXd4O2deqkJNyPjrKZ4KVdfpa.40MS7d*QnTWAVeD9lmpChr6wRrvF0wv3xtrC0Lv8tE4fA!!/b&amp;bo=4gJqBAAAAAADB6w!&amp;rf=viewer_4" alt=""></p> <p>详细的分析一下这题的解题思路：</p> <ol><li>相信有很多小伙伴由第一道题的经验可知：第一轮输出 <code>1</code> 和 <code>7</code>。<strong>这样输出就错了</strong>！相信如果实现上方小节 <code>Promise</code> 源码小节都知道，<code>Promise</code> 参数里的<code>执行器</code>是默认<strong>立即执行</strong>的。故，第一轮输出： <code>1</code> 、<code>3</code>、<code>7</code>。下面分析下执行异步时的情况：</li> <li>同理，<code>2</code> 存放到<strong>宏任务队列</strong>中。由于执行了 <code>resolve(4)</code>，那么第一个 <code>.then</code>方法的成功回调方法中的打印值会存放在<strong>微任务队列</strong>中等待执行。此时，要注意：第二个 <code>.then</code>方法的成功回调不会执行，一直在等待状态。故，第二轮输出：<code>5</code>、<code>4</code>。</li> <li>当第一个 <code>.then</code> 方法执行完后，再执行第二个 <code>.then</code> 方法，并且将成功回调方法中的打印值会存放在<strong>微任务队列</strong>中等待执行。由于第一个 <code>then</code> 方法执行没有 <code>return</code> ，所以第二个 <code>then</code> 参数 <code>data</code> 为 <code>undefined</code>。故，第三轮输出：<code>6</code> 和 <code>undefined</code>。</li> <li>当第三轮<strong>微任务队列</strong>走完后，再走<strong>宏任务队列</strong>，故，第四轮输出：<code>2</code>。</li></ol> <p><strong>注意</strong>：做此题的技巧：同上题技巧。但要明白 <code>Promise</code> 的特点。</p> <h3 id="题目三"><a href="#题目三" class="header-anchor">#</a> 题目三</h3> <blockquote><p>输出一下结果？</p></blockquote> <p><img src="http://m.qpic.cn/psc?/V129bHJB4fgIUn/POwAobJtn54NCYlSXd4O2WMeD92MKfVc1seebPIYjRNllSrJafwLRn2YsoYRjQjEp1pIoXp4trvKWitOYWtDQA!!/b&amp;bo=rgMaBgAAAAADB5M!&amp;rf=viewer_4" alt=""></p> <p>详细的分析一下这题的解题思路：</p> <ol><li>由第二题可知，故，第一轮输出：<code>1</code>、<code>3</code>、<code>9</code>、<code>11</code>。下面分析下执行异步时的情况：</li> <li>同理，<code>2</code> 存放到<strong>宏任务队列</strong>中。第一个 <code>Promise</code> 执行 <code>resolve</code>方法，所以先执行第一个 <code>Promise</code>中的第一个 <code>then</code>方法。<code>4</code>和 <code>5</code> 被存放在<strong>微任务队列</strong>中。但又 <code>new Promise</code> 并且执行 <code>resolve</code> 方法。<strong>注意</strong>：此时，第二个 <code>resolve</code> 执行时，<code>6</code>和<code>7</code>的代码还没有存放在<strong>微任务队列</strong>中。第一个<code>Promise</code> 中的第二个 <code>then</code> 方法中的 <code>8</code>也没有存放在<strong>微任务队列</strong>中。代码执行到三个 <code>new Promise</code> 中调用 <code>resolve</code>方法，所以 <code>10</code> 被存在<strong>微任务队列</strong>中。故，第二轮输出：<code>4</code>、<code>5</code>、<code>10</code>。</li> <li>执行上述分析的<strong>微任务队列</strong>中的 <code>10</code>，当走第二个 <code>Promise</code> 的 <code>resolve</code> 方法时，<code>6</code> 被存放在<strong>微任务队列</strong>中，<code>7</code> 没有存放在<strong>微任务队列</strong>中。此时，<code>8</code>被存放在<strong>微任务队列</strong>中。故，第三轮输出：<code>10</code>、<code>6</code>、<code>8</code>。</li> <li>最后执行第二个 <code>Promise</code> 的 第二个 <code>then</code> 方法。故，第四轮输出：<code>7</code>。</li> <li>当第四轮<strong>微任务队列</strong>走完后，再走<strong>宏任务队列</strong>，故，第四轮输出：<code>2</code>。</li></ol> <p><strong>注意</strong>：做此题的技巧：同上题技巧。但要知道Promise的状态是否是成功或者失败状态回调函数是否执行。</p> <p>通过以上三道有关 <code>Promise</code> 的题，当你完全掌握了 <code>Promise</code>、<code>同步</code>、<code>异步</code>、<code>宏任务</code>、<code>微任务</code>、<code>任务队列</code>、<code>JS执行机制</code>等相关知识点后，这种题都是可以用眼睛就能做出来。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>说实话，Promise 原理实现的代码我差不多写了十遍左右了，每一次写都有不同的感受和体会。希望有需要的小伙伴静下心来自己多摸索着写几篇，当你完完整整的实现过必定对你面试还是个人技术成长有好处。跟我们平时项目需求开发一样，只要思路屡清楚再开始编码，你就会发现原来 Promise 也不是传说中的那么复杂。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/page5/深入解读es6.html" class="prev">
        深入解读es6
      </a></span> <span class="next"><a href="/page5/promise对象的使用.html">
        promise对象的使用
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.f3f0b164.js" defer></script><script src="/assets/js/2.284f78c8.js" defer></script><script src="/assets/js/33.bd99df5c.js" defer></script>
  </body>
</html>
