<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Javscript继承 | 个人网站</title>
    <meta name="description" content="Welcome to come to my blog">
    
    
    <link rel="preload" href="/assets/css/0.styles.c9120bc4.css" as="style"><link rel="preload" href="/assets/js/app.baeebc12.js" as="script"><link rel="preload" href="/assets/js/38.6966b072.js" as="script"><link rel="prefetch" href="/assets/js/10.51912ddf.js"><link rel="prefetch" href="/assets/js/11.e96c3ccb.js"><link rel="prefetch" href="/assets/js/12.3199951e.js"><link rel="prefetch" href="/assets/js/13.3c7197fa.js"><link rel="prefetch" href="/assets/js/14.907c91b1.js"><link rel="prefetch" href="/assets/js/15.bf14723d.js"><link rel="prefetch" href="/assets/js/16.86fb4ac7.js"><link rel="prefetch" href="/assets/js/17.e2cff3df.js"><link rel="prefetch" href="/assets/js/18.48c73241.js"><link rel="prefetch" href="/assets/js/19.8f6142cc.js"><link rel="prefetch" href="/assets/js/2.dd4257e1.js"><link rel="prefetch" href="/assets/js/20.0640987b.js"><link rel="prefetch" href="/assets/js/21.b3d737d8.js"><link rel="prefetch" href="/assets/js/22.3f190a25.js"><link rel="prefetch" href="/assets/js/23.e5855050.js"><link rel="prefetch" href="/assets/js/24.76d4e241.js"><link rel="prefetch" href="/assets/js/25.68803788.js"><link rel="prefetch" href="/assets/js/26.7c73d578.js"><link rel="prefetch" href="/assets/js/27.946ad60e.js"><link rel="prefetch" href="/assets/js/28.f7173b89.js"><link rel="prefetch" href="/assets/js/29.44cce327.js"><link rel="prefetch" href="/assets/js/3.c1011a22.js"><link rel="prefetch" href="/assets/js/30.ca9785fb.js"><link rel="prefetch" href="/assets/js/31.2ee0d2c0.js"><link rel="prefetch" href="/assets/js/32.c7418bd6.js"><link rel="prefetch" href="/assets/js/33.bf2abcee.js"><link rel="prefetch" href="/assets/js/34.abbc5d8e.js"><link rel="prefetch" href="/assets/js/35.b8cd562f.js"><link rel="prefetch" href="/assets/js/36.958f06a4.js"><link rel="prefetch" href="/assets/js/37.c043e7bb.js"><link rel="prefetch" href="/assets/js/39.4724a334.js"><link rel="prefetch" href="/assets/js/4.ee255b66.js"><link rel="prefetch" href="/assets/js/40.1e6f0e95.js"><link rel="prefetch" href="/assets/js/41.de3a8b43.js"><link rel="prefetch" href="/assets/js/42.f5df9fc7.js"><link rel="prefetch" href="/assets/js/43.f8fa8e4a.js"><link rel="prefetch" href="/assets/js/44.c43bf2f3.js"><link rel="prefetch" href="/assets/js/45.7ca64b8f.js"><link rel="prefetch" href="/assets/js/46.dee8a320.js"><link rel="prefetch" href="/assets/js/47.9ee60df4.js"><link rel="prefetch" href="/assets/js/48.a4cd6b21.js"><link rel="prefetch" href="/assets/js/49.1f8ef22d.js"><link rel="prefetch" href="/assets/js/5.a54dcc21.js"><link rel="prefetch" href="/assets/js/50.765b05d2.js"><link rel="prefetch" href="/assets/js/51.d27860af.js"><link rel="prefetch" href="/assets/js/52.bf0188ba.js"><link rel="prefetch" href="/assets/js/53.5208a76e.js"><link rel="prefetch" href="/assets/js/54.ef3432ff.js"><link rel="prefetch" href="/assets/js/55.271739d0.js"><link rel="prefetch" href="/assets/js/56.c3f0caab.js"><link rel="prefetch" href="/assets/js/57.3ff1162b.js"><link rel="prefetch" href="/assets/js/58.27e5128c.js"><link rel="prefetch" href="/assets/js/59.30fa2cb1.js"><link rel="prefetch" href="/assets/js/6.9c13835b.js"><link rel="prefetch" href="/assets/js/60.32defecd.js"><link rel="prefetch" href="/assets/js/61.98a47375.js"><link rel="prefetch" href="/assets/js/62.f833acc8.js"><link rel="prefetch" href="/assets/js/63.9801a855.js"><link rel="prefetch" href="/assets/js/7.258c75b9.js"><link rel="prefetch" href="/assets/js/8.572091d6.js"><link rel="prefetch" href="/assets/js/9.6896af62.js">
    <link rel="stylesheet" href="/assets/css/0.styles.c9120bc4.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">个人网站</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/page3/page1/" class="nav-link">前端技术</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">个人文章</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://juejin.im/user/5c8f3303f265da612d633276" target="_blank" rel="noopener noreferrer" class="nav-link external">
  掘金
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://segmentfault.com/u/helloxiaoming" target="_blank" rel="noopener noreferrer" class="nav-link external">
  segmentfault
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/qq_40588413" target="_blank" rel="noopener noreferrer" class="nav-link external">
  CSDN
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <a href="https://github.com/shifengming" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/page3/page1/" class="nav-link">前端技术</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">个人文章</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://juejin.im/user/5c8f3303f265da612d633276" target="_blank" rel="noopener noreferrer" class="nav-link external">
  掘金
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://segmentfault.com/u/helloxiaoming" target="_blank" rel="noopener noreferrer" class="nav-link external">
  segmentfault
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/qq_40588413" target="_blank" rel="noopener noreferrer" class="nav-link external">
  CSDN
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <a href="https://github.com/shifengming" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading"><span>HTML</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>CSS3</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading open"><span>JavaScript</span> <span class="arrow down"></span></p> <ul class="sidebar-group-items"><li><a href="/page3/JS字符串.html" class="sidebar-link">JS字符串</a></li><li><a href="/page3/JS数组.html" class="sidebar-link">JS数组</a></li><li><a href="/page3/EventLoop.html" class="sidebar-link">EventLoop</a></li><li><a href="/page3/js数据类型.html" class="sidebar-link">JavaScript 数据类型</a></li><li><a href="/page3/对象的深浅拷贝.html" class="sidebar-link">对象的深浅拷贝</a></li><li><a href="/page3/原型与原型链.html" class="sidebar-link">原型与原型链</a></li><li><a href="/page3/this理解.html" class="sidebar-link">this理解</a></li><li><a href="/page3/JavaScript继承.html" class="active sidebar-link">Javscript继承</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/page3/JS常见比较.html" class="sidebar-link">JS常见比较</a></li><li><a href="/page3/闭包.html" class="sidebar-link">闭包</a></li><li><a href="/page3/重点题.html" class="sidebar-link">重点题</a></li></ul></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>JQuery</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>ES6</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Vue</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>React</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>小程序</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Github</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Http请求</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Ajax</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Webpack</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>项目</span> <span class="arrow right"></span></p> <!----></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="javscript继承"><a href="#javscript继承" class="header-anchor">#</a> Javscript继承</h1> <h3 id="预备知识"><a href="#预备知识" class="header-anchor">#</a> 预备知识</h3> <ul><li><ol><li>构造函数的属性</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token comment">// 实例基本属性 (该属性，强调私有，不共享)</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment">// 实例引⽤属性 (该属性，强调私⽤，不共享)</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 实例引⽤属性 (该属性，强调复⽤，需要共享)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <p><strong>注意</strong>：数组和⽅法都属于‘实例引⽤属性’，但是数组强调私有、不共享的。⽅法需要复⽤、共享。 在构造函数中，⼀般很少有数组形式的引⽤属性，⼤部分情况都是：<code>基本属性 + ⽅法</code>。</p> <ul><li><ol start="2"><li>什么是原型对象</li></ol></li></ul> <p>简单来说，每个函数都有 <code>prototype</code> 属性，它就是<code>原型对象</code>，通过函数实例化出来的对象有个 <code>__proto__</code> 属性，指向<code>原型对象</code>。</p> <pre><code>~~~js
let a = new A()
a.__proto__ == A.prototype
// prototype的结构如下
A.prototype = {
    constructor: A,
    ...其他的原型属性和⽅法
}
~~~
</code></pre> <ul><li><ol start="3"><li>原型对象的作用</li></ol> <p>原型对象的⽤途是<code>为每个实例对象存储共享的⽅法和属性</code>，它仅仅是⼀个普通对象⽽已。<strong>并且所有的实例是共享同⼀个原型对象，因此有别于实例⽅法或属性，原型对象仅有⼀份</strong>。⽽实例有很多份，且实例属性和⽅法是独⽴的。在构造函数中：为了属性(实例基本属性)的私有性、以及⽅法(实 例引⽤属性)的复⽤、共享。我们提倡：</p> <ul><li>将属性封装在构造函数中</li> <li>将方法定义在原型对象上</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token comment">// (该属性，强调私有，不共享)</span>
<span class="token punctuation">}</span>
<span class="token class-name">A</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 定义在原型对象上的⽅法 (强调复⽤，需要共享)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 不推荐的写法：[原因](https://blog.csdn.net/kkkkkxiaofei/article/details/46474303)</span>
<span class="token class-name">A</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">say</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h3 id="方式一、原型链继承"><a href="#方式一、原型链继承" class="header-anchor">#</a> 方式一、原型链继承</h3> <ul><li><p>核⼼：将⽗类实例作为⼦类原型</p></li> <li><p>优点：⽅法复⽤</p> <ol><li>由于⽅法定义在⽗类的原型上，复⽤了⽗类构造函数的⽅法。⽐如 say ⽅法。</li></ol></li> <li><p>缺点：</p> <ol><li>创建⼦类实例的时候，不能传⽗类的参数（⽐如 name）。</li> <li>⼦类实例共享了⽗类构造函数的引⽤属性，⽐如 arr 属性。</li> <li>⽆法实现多继承。</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token operator">||</span> <span class="token string">'⽗亲'</span> <span class="token comment">// 实例基本属性 (该属性，强调私有，不共享)</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment">// (该属性，强调私有)</span>
<span class="token punctuation">}</span>
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// -- 将需要复⽤、共享的⽅法定义在⽗类原型上</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">like</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>like <span class="token operator">=</span> like
<span class="token punctuation">}</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 核⼼，但此时Child.prototype.constructor==Parent</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child <span class="token comment">// 修正constructor指向</span>
<span class="token keyword">let</span> boy1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> boy2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 优点：共享了⽗类构造函数的say⽅法</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>boy1<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> boy2<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> boy1<span class="token punctuation">.</span>say <span class="token operator">===</span> boy2<span class="token punctuation">.</span>say<span class="token punctuation">)</span> <span class="token comment">// hello , hello , true</span>
<span class="token comment">// 缺点1：不能向⽗类构造函数传参</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>boy1<span class="token punctuation">.</span>name<span class="token punctuation">,</span> boy2<span class="token punctuation">.</span>name<span class="token punctuation">,</span> boy1<span class="token punctuation">.</span>name <span class="token operator">===</span> boy2<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// ⽗亲，⽗亲，true</span>
<span class="token comment">// 缺点2: ⼦类实例共享了⽗类构造函数的引⽤属性，⽐如arr属性</span>
boy1<span class="token punctuation">.</span>arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 修改了boy1的arr属性，boy2的arr属性，也会变化，因为两个实例的原型上(Child.prototype)有了⽗类构造函数的实例属性arr； 所以只要修改了boy1.arr，boy2.arr的属性也会变化。</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>boy2<span class="token punctuation">.</span>arr<span class="token punctuation">)</span> <span class="token comment">// [1,2]</span>

注意<span class="token number">1</span>：修改boy1的name属性，是不会影响到boy2<span class="token punctuation">.</span>name。因为设置boy1<span class="token punctuation">.</span>name相当于在⼦类实例新增了name属性。

注意<span class="token number">2</span>： console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>boy1<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Parent 你会发现实例的构造函数居然是Parent。 ⽽实际上，我们希望⼦类实例的构造函数是Child,所以要记得修复构造函数指向。 修复如下：Child.prototype.constructor = Child;</span>
</code></pre></div></li></ul> <h3 id="方式二、借用构造函数"><a href="#方式二、借用构造函数" class="header-anchor">#</a> 方式二、借用构造函数</h3> <ul><li><p>核⼼：借⽤⽗类的构造函数来增强⼦类实例，等于是复制⽗类的实例属性给⼦类。</p></li> <li><p>优点：实例之间独⽴</p> <ol><li>创建⼦类实例，可以向⽗类构造函数传参数。</li> <li>⼦类实例不共享⽗类构造函数的引⽤属性。如 arr 属性</li> <li>可实现多继承（通过多个 call 或者 apply 继承多个⽗类）</li></ol></li> <li><p>缺点：</p> <ol><li>⽗类的⽅法不能复⽤（由于⽅法在⽗构造函数中定义，导致⽅法不能复⽤(因为每次创建⼦类实例都要创建⼀遍⽅法)。 ⽐如 say ⽅法。(⽅法应该要复⽤、共享)）</li> <li>⼦类实例，继承不了⽗类原型上的属性。(因为没有⽤到原型)</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token comment">// 实例基本属性 (该属性，强调私有，不共享)</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment">// (该属性，强调私有)</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 实例引⽤属性 (该属性，强调复⽤，需要共享)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> like</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token comment">// 核⼼ 拷⻉了⽗类的实例属性和⽅法</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>like <span class="token operator">=</span> like
<span class="token punctuation">}</span>
<span class="token keyword">let</span> boy1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'⼩红'</span><span class="token punctuation">,</span> <span class="token string">'apple'</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> boy2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'⼩明'</span><span class="token punctuation">,</span> <span class="token string">'orange'</span><span class="token punctuation">)</span>
<span class="token comment">// 优点1：可向⽗类构造函数传参</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>boy1<span class="token punctuation">.</span>name<span class="token punctuation">,</span> boy2<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// ⼩红， ⼩明</span>
<span class="token comment">// 优点2：不共享⽗类构造函数的引⽤属性</span>
boy1<span class="token punctuation">.</span>arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>boy1<span class="token punctuation">.</span>arr<span class="token punctuation">,</span> boy2<span class="token punctuation">.</span>arr<span class="token punctuation">)</span> <span class="token comment">// [1,2] [1]</span>
<span class="token comment">// 缺点1：⽅法不能复⽤</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>boy1<span class="token punctuation">.</span>say <span class="token operator">===</span> boy2<span class="token punctuation">.</span>say<span class="token punctuation">)</span> <span class="token comment">// false (说明，boy1和boy2的say⽅法是独⽴，不是共享的)</span>
<span class="token comment">// 缺点2：不能继承⽗类原型上的⽅法</span>
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">walk</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 在⽗类的原型对象上定义⼀个walk⽅法。</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我会⾛路'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
boy1<span class="token punctuation">.</span>walk <span class="token comment">// undefined (说明实例，不能获得⽗类原型上的⽅法)</span>
</code></pre></div></li></ul> <h3 id="方式三、组合继承"><a href="#方式三、组合继承" class="header-anchor">#</a> 方式三、组合继承</h3> <ul><li>核⼼：通过调⽤⽗类构造函数，继承⽗类的属性并保留传参的优点；然后通过将⽗类实例作为 ⼦类原型，实现函数复⽤。</li> <li>优点：
<ol><li>保留构造函数的优点：创建⼦类实例，可以向⽗类构造函数传参数。</li> <li>保留原型链的优点：⽗类的⽅法定义在⽗类的原型对象上，可以实现⽅法复⽤。</li> <li>不共享⽗类的引⽤属性。⽐如 arr 属性</li></ol></li> <li>缺点：
<ol><li>由于调⽤了 2 次⽗类的构造⽅法，会存在⼀份多余的⽗类实例属性，具体原因⻅⽂末。</li></ol></li></ul> <p><strong>注意</strong>：'组合继承'这种⽅式，要记得修复 Child.prototype.constructor 指向 第⼀次 Parent.call(this);从⽗类拷⻉⼀份⽗类实例属性，作为⼦类的实例属性，第⼆次 Child.prototype = new Parent();创建⽗类实例作为⼦类原型，Child.prototype 中的⽗类属性和⽅法 会被第⼀次拷⻉来的实例属性屏蔽掉，所以多余。</p> <pre><code>~~~js
function Parent(name) {
    this.name = name; // 实例基本属性 (该属性，强调私有，不共享)
    this.arr = [1]; // (该属性，强调私有)
}
Parent.prototype.say = function() { // --- 将需要复⽤、共享的⽅法定义在⽗类原型上
    console.log('hello')
}
function Child(name,like) {
    Parent.call(this,name,like) // 核⼼ 第⼆次
    this.like = like;
}
Child.prototype = new Parent() // 核⼼ 第⼀次
Child.prototype.constructor = Child // 修正constructor指向
let boy1 = new Child('⼩红','apple')
let boy2 = new Child('⼩明','orange')
// 优点1：可以向⽗类构造函数传参数
console.log(boy1.name,boy1.like); // ⼩红，apple
// 优点2：可复⽤⽗类原型上的⽅法
console.log(boy1.say === boy2.say) // true
// 优点3：不共享⽗类的引⽤属性，如arr属性
boy1.arr.push(2)
console.log(boy1.arr,boy2.arr); // [1,2] [1] 可以看出没有共享arr属性。
// 缺点1：由于调⽤了2次⽗类的构造⽅法，会存在⼀份多余的⽗类实例属性
~~~

其实Child.prototype = new Parent() console.log(Child.prototype.__proto__ === Parent.prototype); // true 因为Child.prototype等于Parent的实例，所以__proto__指向Parent.prototype
</code></pre> <h3 id="方式四、组合继承优化-1"><a href="#方式四、组合继承优化-1" class="header-anchor">#</a> 方式四、组合继承优化 1</h3> <ul><li>核⼼： 通过这种⽅式，砍掉⽗类的实例属性，这样在调⽤⽗类的构造函数的时候，就不会初始化两次实 例，避免组合继承的缺点。</li> <li>优点：
<ol><li>只调⽤⼀次⽗类构造函数。</li> <li>保留构造函数的优点：创建⼦类实例，可以向⽗类构造函数传参数。</li> <li>保留原型链的优点：⽗类的实例⽅法定义在⽗类的原型对象上，可以实现⽅法复⽤。</li></ol></li> <li>缺点：
<ol><li>修正构造函数的指向之后，⽗类实例的构造函数指向，同时也发⽣变化(这是我们不希望的)</li></ol></li></ul> <p><strong>注意</strong>：'组合继承优化 1'这种⽅式，要记得修复 Child.prototype.constructor 指向 原因是：不能判断⼦类实例的直接构造函数，到底是⼦类构造函数还是⽗类构造函数。</p> <pre><code>~~~js
function Parent(name) {
    this.name = name; // 实例基本属性 (该属性，强调私有，不共享)
    this.arr = [1]; // (该属性，强调私有)
}
Parent.prototype.say = function() { // --- 将需要复⽤、共享的⽅法定义在⽗类原型上
    console.log('hello')
}
function Child(name,like) {
    Parent.call(this,name,like) // 核⼼
    this.like = like;
}
Child.prototype = Parent.prototype // 核⼼ ⼦类原型和⽗类原型，实质上是同⼀个
&lt;!--这⾥是修复构造函数指向的代码--&gt;
Child.prototype.constructor = Child
let boy1 = new Child('⼩红','apple')
let boy2 = new Child('⼩明','orange')
let p1 = new Parent('⼩爸爸')
// 优点1：可以向⽗类构造函数传参数
console.log(boy1.name,boy1.like); // ⼩红，apple
// 优点2：可复⽤⽗类原型上的⽅法
console.log(boy1.say === boy2.say) // true
// 缺点1：当修复⼦类构造函数的指向后，⽗类实例的构造函数指向也会跟着变了。
没修复之前：console.log(boy1.constructor); // Parent
修复代码：Child.prototype.constructor = Child
修复之后：console.log(boy1.constructor); // Child
console.log(p1.constructor);// Child 这⾥就是存在的问题(我们希望是Parent)
具体原因：因为是通过原型来实现继承的，Child.prototype的上⾯是没有constructor属性的， 就会往上找，这样就找到了Parent.prototype上⾯的constructor属性；当你修改了⼦类实例的 constructor属性，所有的constructor的指向都会发⽣变化。
~~~
</code></pre> <h3 id="方式五、组合继承优化-2-⼜称-寄⽣组合继承-完美⽅式"><a href="#方式五、组合继承优化-2-⼜称-寄⽣组合继承-完美⽅式" class="header-anchor">#</a> 方式五、组合继承优化 2 ⼜称 寄⽣组合继承 --- 完美⽅式</h3> <pre><code>~~~js
function Parent(name) {
    this.name = name; // 实例基本属性 (该属性，强调私有，不共享)
    this.arr = [1]; // (该属性，强调私有)
}
Parent.prototype.say = function() { // --- 将需要复⽤、共享的⽅法定义在⽗类原型上
    console.log('hello')
}
function Child(name,like) {
    Parent.call(this,name,like) // 核⼼
    this.like = like;
}
// 核⼼ 通过创建中间对象，⼦类原型和⽗类原型，就会隔离开。不是同⼀个啦，有效避免了⽅式4的缺点。
Child.prototype = Object.create(Parent.prototype) // 这⾥是修复构造函数指向的代码
Child.prototype.constructor = Child
let boy1 = new Child('⼩红','apple')
let boy2 = new Child('⼩明','orange')
let p1 = new Parent('⼩爸爸')
注意：这种⽅法也要修复构造函数的
修复代码：Child.prototype.constructor = Child
修复之后：console.log(boy1.constructor); // Child
console.log(p1.constructor); // Parent 完美😊
~~~
</code></pre> <h3 id="其他相关问题"><a href="#其他相关问题" class="header-anchor">#</a> 其他相关问题</h3> <ul><li><p>Object.create(object, propertiesObject)</p> <p>Object.create()⽅法创建⼀个新对象，使⽤第⼀个参数来提供新创建对象的<code>__proto__</code>（以第⼀个参 数作为新对象的构造函数的原型对象）； ⽅法还有第⼆个可选参数，是添加到新创建对象的属性，写法如下。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> a <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">12</span><span class="token punctuation">,</span>
    <span class="token literal-property property">writable</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token literal-property property">configurable</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p><strong>扩展</strong>：new 与 Object.create() 的区别？</p> <p>new 产⽣的实例，优先获取构造函数上的属性；构造函数上没有对应的属性，才会去原型上查找； 如果构造函数中以及原型中都没有对应的属性，就会报错。</p> <p>Object.create() 产⽣的对象，只会在原 型上进⾏查找属性，原型上没有对应的属性，就会报错。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">Base1</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> o1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Base1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> o2 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Base1</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o1<span class="token punctuation">.</span>a<span class="token punctuation">)</span> <span class="token comment">// 1</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o2<span class="token punctuation">.</span>a<span class="token punctuation">)</span> <span class="token comment">// undefined</span>
<span class="token keyword">let</span> <span class="token function-variable function">Base2</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">Base2</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token string">'aa'</span>
<span class="token keyword">let</span> o3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Base2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> o4 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Base2</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o3<span class="token punctuation">.</span>a<span class="token punctuation">)</span> <span class="token comment">// aa</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o4<span class="token punctuation">.</span>a<span class="token punctuation">)</span> <span class="token comment">// aa</span>
<span class="token keyword">let</span> <span class="token function-variable function">Base3</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
<span class="token class-name">Base3</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token string">'aa'</span>
<span class="token keyword">let</span> o5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Base3</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> o6 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Base3</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o5<span class="token punctuation">.</span>a<span class="token punctuation">)</span> <span class="token comment">// 1</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o6<span class="token punctuation">.</span>a<span class="token punctuation">)</span> <span class="token comment">// aa</span>
</code></pre></div></li> <li><p>new 的过程？</p> <ol><li>创建新对象（如 obj）。</li> <li>将新对象的<em>proto</em>指向构造函数的 prototype 对象。</li> <li>执⾏构造函数，为这个新对象添加属性，并将 this 指向创建的新对象 obj。</li> <li>当构造函数本⾝返回值为对象时，返回该对象，否则返回新对象。</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//创建Person构造函数，参数为name,age</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>age</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">_new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//1.拿到传⼊的参数中的第⼀个参数，即构造函数名Func</span>
    <span class="token keyword">var</span> Func <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//2.创建⼀个空对象obj,并让其继承Func.prototype</span>
    <span class="token keyword">var</span> obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Func</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//3.执⾏构造函数，并将this指向创建的空对象obj</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">Func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span>arguments<span class="token punctuation">)</span>
    <span class="token comment">//4.当函数也有返回值且为对象时返回该对象，否则返回创建的新对象obj</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>result instanceOf Object <span class="token operator">?</span> result <span class="token operator">:</span> obj<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> ming <span class="token operator">=</span> <span class="token function">_new</span><span class="token punctuation">(</span>Person<span class="token punctuation">,</span><span class="token string">'tmc'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ming<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>[].shift.call</code>表⽰删除并返回<code>arguments[0]</code>。也可以通过以下⽅式取得函数名和函数的参数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">_new</span><span class="token punctuation">(</span><span class="token parameter">Func<span class="token punctuation">,</span> <span class="token operator">...</span>params</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
</code></pre></div><p><code>Object.create</code>创建<code>obj</code>，使得<code>obj.__proto__ = Func.prototype</code></p></li> <li><p>为什么‘组合继承’这种⽅式，会执⾏两次⽗类构造函数？</p> <ol><li><p>第⼀次：Child.prototype = new Parent()</p> <p>new 的过程’的第三步，其实就是执⾏了⽗类构造函数。</p></li> <li><p>第⼆次：Parent.call(this,name,like)</p> <p>call 的作⽤是改变函数执⾏时的上下⽂。⽐如：A.call(B)。其实，最终执⾏的还是 A 函数，只不过是 ⽤ B 来调⽤⽽已。所以，你就懂了 Parent.call(this,name,like) ,也就是执⾏了⽗类构造函数 Person。</p></li></ol></li></ul></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/app.baeebc12.js" defer></script><script src="/assets/js/38.6966b072.js" defer></script>
  </body>
</html>
