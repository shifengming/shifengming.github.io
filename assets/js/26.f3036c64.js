(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{218:function(s,n,e){"use strict";e.r(n);var o=e(0),t=Object(o.a)({},(function(){var s=this,n=s.$createElement,e=s._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h1",{attrs:{id:"事件循环原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件循环原理"}},[s._v("#")]),s._v(" 事件循环原理")]),s._v(" "),e("h2",{attrs:{id:"经典题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#经典题"}},[s._v("#")]),s._v(" 经典题")]),s._v(" "),e("p",[s._v("下面这段promise、async和await代码，请问控制台打印顺序？")]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("async function async1() {\n    console.log('async1 start');\n    await async2();\n    console.log('async1 end');\n}\nasync function async2() {\n    console.log('async2');\n}\nconsole.log('script start');\nsetTimeout(function() {\n    console.log('setTimeout');\n}, 0)\nasync1();\nnew Promise(function(resolve) {\n    console.log('promise1');\n    resolve();\n}).then(function() {\n    console.log('promise2');\n});\nconsole.log('script end');\n")])])]),e("p",[e("strong",[s._v("正确答案")])]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("script start\nasync1 start\nasync2\npromise1\nscript end\nasync1 end\npromise2\nsetTimeout\n")])])]),e("p",[e("strong",[s._v("注：因为是一道前端面试题，所以答案是以浏览器的eventloop机制为准的，在node平台上运行会有差异")])]),s._v(" "),e("p",[e("strong",[s._v("相信大多数前端都知道，这道题考的就是js里面的事件循环和任务队列")])]),s._v(" "),e("h2",{attrs:{id:"知识点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#知识点"}},[s._v("#")]),s._v(" 知识点")]),s._v(" "),e("p",[e("strong",[s._v("同步任务、异步任务、宏任务、微任务、任务队列、执行栈、js运行机制、Event Loop")])]),s._v(" "),e("p",[e("strong",[s._v("这题考察的是js中的事件循环和任务队列，注意以下几点：")])]),s._v(" "),e("ul",[e("li",[s._v("Promise优先于setTimeout宏任务。所以，setTimeout回调会在最后执行")]),s._v(" "),e("li",[s._v("Promise一旦被定义，就会立即执行")]),s._v(" "),e("li",[s._v("Promise的reject和resolve是异步执行的回调。所以，resolve()会被放到回调队列中，在主函数执行完和setTimeout前调用")]),s._v(" "),e("li",[s._v("await执行完后，会让出线程。async标记的函数会返回一个Promise对象")])]),s._v(" "),e("h2",{attrs:{id:"async介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#async介绍"}},[s._v("#")]),s._v(" async介绍")]),s._v(" "),e("ul",[e("li",[s._v("async function 声明将定义一个返回 AsyncFunction 对象的异步函数")]),s._v(" "),e("li",[s._v("当调用一个 async 函数时，会返回一个 Promise 对象")]),s._v(" "),e("li",[s._v("当这个 async 函数返回一个值时，Promise 的 resolve 方法会负责传递这个值")]),s._v(" "),e("li",[s._v("当 async 函数抛出异常时，Promise 的 reject 方法也会传递这个异常值")])]),s._v(" "),e("p",[e("strong",[s._v("它通过返回一个 Promise 对象来返回结果最大的特点是：")])]),s._v(" "),e("blockquote",[e("p",[s._v("通过 async / await 将异步的操作，但写法和结构却是和我们平时写的（同步代码）是一样")])]),s._v(" "),e("h2",{attrs:{id:"await"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#await"}},[s._v("#")]),s._v(" await")]),s._v(" "),e("ul",[e("li",[s._v("await操作符用于等待一个Promise对象")]),s._v(" "),e("li",[s._v("await表达式会暂停当前async")]),s._v(" "),e("li",[s._v("function的执行，等待Promise处理完成，若Promise正常处理,其回调的resolve函数参数作为await表达式的值，继续执行async function")]),s._v(" "),e("li",[s._v("await意味让出线程操作")])]),s._v(" "),e("p",[e("strong",[s._v("返回值（return_value）：返回 Promise 对象的处理结果。如果等待的不是 Promise 对象，则返回该值本身,")])]),s._v(" "),e("p",[e("strong",[s._v("所以，当await操作符后面的表达式是一个Promise的时候，它的返回值，实际上就是Promise的回调函数resolve的参数")])]),s._v(" "),e("p",[e("strong",[s._v("我们都知道Promise是一个立即执行函数，但是他的成功（或失败：reject）的回调函数resolve却是一个异步执行的回调。当执行到resolve()时，这个任务会被放入到回调队列中，等待调用栈有空闲时事件循环再来取走它")])]),s._v(" "),e("h2",{attrs:{id:"promise"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[s._v("#")]),s._v(" promise")]),s._v(" "),e("p",[e("strong",[s._v("async会返回Promise对象，如果返回值不是Promise对象则调用Promise resolve来换成Promise对象")])]),s._v(" "),e("p",[e("strong",[s._v("async/await建立在Prmise机制上")])]),s._v(" "),e("p",[e("strong",[s._v("总结一句话：带async关键字的函数，它使得你的函数的返回值必定是 promise 对象上")])]),s._v(" "),e("h2",{attrs:{id:"evenloop"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#evenloop"}},[s._v("#")]),s._v(" EvenLoop")]),s._v(" "),e("blockquote",[e("p",[s._v("这里先简单的说一些Event Loop的概念，在最近这段时间我会写一篇关于Event Loop的文章")])]),s._v(" "),e("p",[e("strong",[s._v("Javascript是单线程的，所有的同步任务都会在主线程中执行")])]),s._v(" "),e("p",[e("strong",[s._v("主线程之外，还有一个任务队列。每当一个异步任务有结果了，就往任务队列里塞一个事件。\n当主线程中的任务，都执行完之后，系统会 “依次” 读取任务队列里的事件。与之相对应的异步任务进入主线程，开始执行")])]),s._v(" "),e("p",[e("strong",[s._v("异步任务之间，会存在差异，所以它们执行的优先级也会有区别。大致分为 微任务（micro task，如：Promise、MutaionObserver等）和宏任务（macro task，如：setTimeout、setInterval、I/O等）。同一次事件循环中，微任务永远在宏任务之前执行")])]),s._v(" "),e("p",[e("strong",[s._v("主线程会不断重复上面的步骤，直到执行完所有任务")])]),s._v(" "),e("h2",{attrs:{id:"题目结果分析过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#题目结果分析过程"}},[s._v("#")]),s._v(" 题目结果分析过程")]),s._v(" "),e("p",[e("strong",[s._v("第一步，输出script start")])]),s._v(" "),e("p",[e("strong",[s._v("虽然有两个函数声明，有async关键字，但是没有调用我们就不看，直接打印同步代码console.log(‘script start’)")])]),s._v(" "),e("p",[e("strong",[s._v("第二步，输出async1 start")])]),s._v(" "),e("p",[e("strong",[s._v("在执行async1这个函数的时候，async表达式定义的函数也是立即执行\n在前面我们说过看到带有async关键字函数，不用慌，它仅仅是把return值包装成了promise,所以就很普通的打印 console.log( 'async1 start' )")])]),s._v(" "),e("p",[e("strong",[s._v("第三步，输出async2")])]),s._v(" "),e("p",[e("strong",[s._v("async2是async定义的函数，输出async2并返回promise对象，\nawait后，中断async函数，先执行async外的同步代码，\n目前就直接打印 console.log('async2')")])]),s._v(" "),e("p",[e("strong",[s._v("第四步，输出promise1")])]),s._v(" "),e("p",[e("strong",[s._v("执行new Promise()，Promise构造函数是直接调用的同步代码，所以就打印console.log( 'promise1' )")])]),s._v(" "),e("p",[e("strong",[s._v("第五步，输出script end")])]),s._v(" "),e("p",[e("strong",[s._v("因为上一步先打印了promise1,然后执行到resolve的时候，然后跳出promise继续向下执行，所以就打印console.log( 'script end' )")])]),s._v(" "),e("p",[e("strong",[s._v("第六步，输出async1 end")])]),s._v(" "),e("p",[e("strong",[s._v("因为await定义的这个promise已经执行完，并且返回结果，所以继续执行async1函数后的任务，就是console.log(‘async1 end’)")])]),s._v(" "),e("p",[e("strong",[s._v("第七步，输出promise2")])]),s._v(" "),e("p",[e("strong",[s._v("因为前面的new promise放进resolve回调，这个resolve被放到调用栈执行,所以就打印console.log('promise')")])]),s._v(" "),e("p",[e("strong",[s._v("第八步，输出setTimerout")])]),s._v(" "),e("p",[e("strong",[s._v("最后执行定时器（宏任务）setTimeout,打印console.log( 'setTimerout' )")])]),s._v(" "),e("h2",{attrs:{id:"题目变式一"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#题目变式一"}},[s._v("#")]),s._v(" 题目变式一")]),s._v(" "),e("p",[e("strong",[s._v("在这个变式中我将async2中的函数也变成了Promise函数，代码如下：")])]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("async function async1() {\n    console.log('async1 start');\n    await async2();\n    console.log('async1 end');\n}\nasync function async2() {\n    //async2做出如下更改：\n    new Promise(function(resolve) {\n    console.log('promise1');\n    resolve();\n}).then(function() {\n    console.log('promise2');\n    });\n}\nconsole.log('script start');\n\nsetTimeout(function() {\n    console.log('setTimeout');\n}, 0)\nasync1();\n\nnew Promise(function(resolve) {\n    console.log('promise3');\n    resolve();\n}).then(function() {\n    console.log('promise4');\n});\n\nconsole.log('script end');\n")])])]),e("p",[e("strong",[s._v("正确答案")])]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("script start\nasync1 start\npromise1\npromise3\nscript end\npromise2\nasync1 end\npromise4\nsetTimeout\n")])])]),e("h2",{attrs:{id:"题目变式二"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#题目变式二"}},[s._v("#")]),s._v(" 题目变式二")]),s._v(" "),e("p",[e("strong",[s._v("我将async1中await后面的代码和async2的代码都改为异步的，代码如下：")])]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("async function async1() {\n    console.log('async1 start');\n    await async2();\n    //更改如下：\n    setTimeout(function() {\n        console.log('setTimeout1')\n    },0)\n}\nasync function async2() {\n    //更改如下：\n    setTimeout(function() {\n        console.log('setTimeout2')\n    },0)\n}\nconsole.log('script start');\n\nsetTimeout(function() {\n    console.log('setTimeout3');\n}, 0)\nasync1();\n\nnew Promise(function(resolve) {\n    console.log('promise1');\n    resolve();\n}).then(function() {\n    console.log('promise2');\n});\nconsole.log('script end');\n")])])]),e("p",[e("strong",[s._v("正确答案")])]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("script start\nasync1 start\npromise1\nscript end\npromise2\nsetTimeout3\nsetTimeout2\nsetTimeout1\n")])])]),e("h2",{attrs:{id:"题目变式三"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#题目变式三"}},[s._v("#")]),s._v(" 题目变式三")]),s._v(" "),e("p",[e("strong",[s._v("这道题整体来说与上面题大同小异与，代码如下：")])]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("async function a1 () {\n    console.log('a1 start')\n    await a2()\n    console.log('a1 end')\n}\nasync function a2 () {\n    console.log('a2')\n}\n\nconsole.log('script start')\n\nsetTimeout(() => {\n    console.log('setTimeout')\n}, 0)\n\nPromise.resolve().then(() => {\n    console.log('promise1')\n})\n\na1()\n\nlet promise2 = new Promise((resolve) => {\n    resolve('promise2.then')\n    console.log('promise2')\n})\n\npromise2.then((res) => {\n    console.log(res)\n    Promise.resolve().then(() => {\n        console.log('promise3')\n    })\n})\nconsole.log('script end')\n")])])]),e("p",[e("strong",[s._v("正确答案")])]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("script start\na1 start\na2\npromise2\nscript end\npromise1\na1 end\npromise2.then\npromise3\nsetTimeout\n")])])])])}),[],!1,null,null,null);n.default=t.exports}}]);