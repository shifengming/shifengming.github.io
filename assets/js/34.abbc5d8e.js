(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{204:function(e,t,s){"use strict";s.r(t);var n=s(0),v=Object(n.a)({},(function(){this._self._c;return this._m(0)}),[function(){var e=this,t=e._self._c;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"eventloop"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#eventloop"}},[e._v("#")]),e._v(" EventLoop")]),e._v(" "),t("p",[e._v("javascript 是一门单线程语言，所以我们可以得出结论：javascript 是按照语句出现的顺序执行的")]),e._v(" "),t("p",[e._v("大家以为 js 都是这样的：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let a = '1'\nconsole.log(a)\n\nlet b = '2'\nconsole.log(b)\n")])])]),t("p",[e._v("然而实际上 js 是这样的：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("setTimeout(function() {\n  console.log('定时器开始啦')\n})\n\nnew Promise(function(resolve) {\n  console.log('马上执行for循环啦')\n  for (var i = 0; i < 10000; i++) {\n    i == 99 && resolve()\n  }\n}).then(function() {\n  console.log('执行then函数啦')\n})\n\nconsole.log('代码执行结束')\n")])])]),t("h2",{attrs:{id:"关于javascript"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#关于javascript"}},[e._v("#")]),e._v(" 关于javaScript")]),e._v(" "),t("p",[t("code",[e._v("javascript")]),e._v(" 是一门单线程语言，在最新的 "),t("code",[e._v("HTML5")]),e._v(" 中提出了 "),t("code",[e._v("Web-Worker")]),e._v("，但 "),t("code",[e._v("javascript")]),e._v(" 是单线程这一核心仍未改变。\n所以一切 "),t("code",[e._v("javascript")]),e._v(' 版的"多线程"都是用单线程模拟出来的，一切 '),t("code",[e._v("javascript")]),e._v(" 多线程都是纸老虎！")]),e._v(" "),t("h2",{attrs:{id:"javascript-事件循环"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#javascript-事件循环"}},[e._v("#")]),e._v(" javascript 事件循环")]),e._v(" "),t("p",[e._v("既然 "),t("code",[e._v("js")]),e._v(" 是单线程，那就像只有一个窗口的银行，客户需要排队一个一个办理业务，同理 "),t("code",[e._v("js")]),e._v(" 任务也要一个一个顺序执行。")]),e._v(" "),t("p",[e._v("如果一个任务耗时过长，那么后一个任务也必须等着。那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？")]),e._v(" "),t("p",[e._v("因此聪明的程序员将任务分为两类：")]),e._v(" "),t("ul",[t("li",[e._v("同步任务")]),e._v(" "),t("li",[e._v("异步任务")])]),e._v(" "),t("p",[e._v("当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。")]),e._v(" "),t("p",[e._v("关于这部分有严格的文字定义，但本文的目的是用最小的学习成本彻底弄懂执行机制，所以我们用导图来说明：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://tangmengcheng.github.io/assets/img/6.055ab155.png",alt:"cmd-markdown-logo"}})]),e._v(" "),t("p",[e._v("导图要表达的内容用文字来表述的话：")]),e._v(" "),t("ul",[t("li",[e._v('同步和异步任务分别进入不同的执行"场所"，同步的进入主线程，异步的进入 '),t("code",[e._v("Event Table")]),e._v(" 并注册函数。")]),e._v(" "),t("li",[e._v("当指定的事情完成时，"),t("code",[e._v("Event Table")]),e._v(" 会将这个函数移入 "),t("code",[e._v("Event Queue")]),e._v("。")]),e._v(" "),t("li",[e._v("主线程内的任务执行完毕为空，会去 "),t("code",[e._v("Event Queue")]),e._v(" 读取对应的函数，进入主线程执行。")]),e._v(" "),t("li",[e._v("上述过程会不断重复，也就是常说的 "),t("code",[e._v("Event Loop")]),e._v("(事件循环)。")])]),e._v(" "),t("p",[e._v("我们不禁要问了，那怎么知道主线程执行栈为空啊？js 引擎存在 monitoring process 进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去 Event Queue 那里检查是否有等待被调用的函数。")]),e._v(" "),t("p",[e._v("说了这么多文字，不如直接一段代码更直白：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let data = []\n$.ajax({\n  url: www.javascript.com,\n  data: data,\n  success: () => {\n    console.log('发送成功!')\n  },\n})\nconsole.log('代码执行结束')\n")])])]),t("p",[e._v("上面是一段简易的 ajax 请求代码：")]),e._v(" "),t("ul",[t("li",[e._v("ajax 进入 Event Table，注册回调函数 success")]),e._v(" "),t("li",[e._v("执行 console.log('代码执行结束')")]),e._v(" "),t("li",[e._v("ajax 事件完成，回调函数 success 进入 Event Queue")]),e._v(" "),t("li",[e._v("线程从 Event Queue 读取回调函数 success 并执行")])]),e._v(" "),t("h2",{attrs:{id:"settimeout"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#settimeout"}},[e._v("#")]),e._v(" setTimeout")]),e._v(" "),t("p",[e._v("我们经常这么实现延时 3 秒执行：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("setTimeout(() => {\n  console.log('延时3秒')\n}, 3000)\n")])])]),t("p",[e._v("渐渐的 setTimeout 用的地方多了，问题也出现了，有时候明明写的延时 3 秒，实际却 5，6 秒才执行函数，这又咋回事啊？")]),e._v(" "),t("p",[e._v("先看一个例子：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("setTimeout(() => {\n  task()\n}, 3000)\nconsole.log('执行console')\n")])])]),t("p",[e._v("根据前面我们的结论，setTimeout 是异步的，应该先执行 console.log 这个同步任务，所以我们的结论是：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//执行console\n//task()\n")])])]),t("p",[e._v("去验证一下，结果正确！")]),e._v(" "),t("p",[e._v("然后我们修改一下前面的代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("setTimeout(() => {\n  task()\n}, 3000)\n\nsleep(10000000)\n")])])]),t("p",[e._v("乍一看其实差不多嘛，但我们把这段代码在 chrome 执行一下，却发现控制台执行 task()需要的时间远远超过 3 秒，说好的延时三秒，为啥现在需要这么长时间啊？")]),e._v(" "),t("p",[e._v("这时候我们需要重新理解 setTimeout 的定义。我们先说上述代码是怎么执行的：")]),e._v(" "),t("ul",[t("li",[e._v("task()进入 Event Table 并注册,计时开始。")]),e._v(" "),t("li",[e._v("执行 sleep 函数，很慢，非常慢，计时仍在继续。")]),e._v(" "),t("li",[e._v("3 秒到了，计时事件 timeout 完成，task()进入 Event Queue，但是 sleep 也太慢了吧，还没执行完，只好等着。")]),e._v(" "),t("li",[e._v("sleep 终于执行完了，task()终于从 Event Queue 进入了主线程执行")])]),e._v(" "),t("p",[e._v("上述的流程走完，我们知道 setTimeout 这个函数，是经过指定时间后，把要执行的任务(本例中为 task())加入到 Event Queue 中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于 3 秒。")]),e._v(" "),t("p",[e._v("我们还经常遇到 setTimeout(fn,0)这样的代码，0 秒后执行又是什么意思呢？是不是可以立即执行呢？")]),e._v(" "),t("p",[e._v("答案是不会的，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。举例说明：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//代码1\nconsole.log('先执行这里')\nsetTimeout(() => {\n  console.log('执行啦')\n}, 0)\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//代码2\nconsole.log('先执行这里')\nsetTimeout(() => {\n  console.log('执行啦')\n}, 3000)\n")])])]),t("p",[e._v("代码 1 的输出结果是：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//先执行这里\n//执行啦\n")])])]),t("p",[e._v("代码 2 的输出结果是：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//先执行这里\n// ... 3s later\n// 执行啦\n")])])]),t("p",[e._v("关于 setTimeout 要补充的是，即便主线程为空，0 毫秒实际上也是达不到的。根据 HTML 的标准，最低是 4 毫秒")]),e._v(" "),t("h2",{attrs:{id:"setinterval"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#setinterval"}},[e._v("#")]),e._v(" setInterval")]),e._v(" "),t("p",[e._v("上面说完了 setTimeout，当然不能错过它的孪生兄弟 setInterval。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，setInterval 会每隔指定的时间将注册的函数置入 Event Queue，如果前面的任务耗时太久，那么同样需要等待。")]),e._v(" "),t("p",[e._v("唯一需要注意的一点是，对于 setInterval(fn,ms)来说，我们已经知道不是每过 ms 秒会执行一次 fn，而是每过 ms 秒，会有 fn 进入 Event Queue。一旦 setInterval 的回调函数 fn 执行时间超过了延迟时间 ms，那么就完全看不出来有时间间隔了。这句话请读者仔细品味。")]),e._v(" "),t("h2",{attrs:{id:"promise-与-process-nexttick-callback"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-与-process-nexttick-callback"}},[e._v("#")]),e._v(" Promise 与 process.nextTick(callback)")]),e._v(" "),t("p",[e._v("传统的定时器我们已经研究过了，接着我们探究 Promise 与 process.nextTick(callback)的表现。")]),e._v(" "),t("p",[e._v('Promise 的定义和功能本文不再赘述，而 process.nextTick(callback)类似 node.js 版的"setTimeout"，在事件循环的下一次循环中调用 callback 回调函数。')]),e._v(" "),t("p",[e._v("我们进入正题，除了广义的同步任务和异步任务，我们对任务有更精细的定义：")]),e._v(" "),t("ul",[t("li",[e._v("macro-task(宏任务)：包括整体代码 script，setTimeout，setInterval")]),e._v(" "),t("li",[e._v("micro-task(微任务)：Promise，process.nextTick")])]),e._v(" "),t("p",[e._v("不同类型的任务会进入对应的 Event Queue，比如 setTimeout 和 setInterval 会进入相同的 Event Queue。")]),e._v(" "),t("p",[e._v("事件循环的顺序，决定 js 代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。")]),e._v(" "),t("p",[e._v("听起来有点绕，我们用文章最开始的一段代码说明：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("setTimeout(function() {\n  console.log('setTimeout')\n})\n\nnew Promise(function(resolve) {\n  console.log('promise')\n}).then(function() {\n  console.log('then')\n})\n\nconsole.log('console')\n")])])]),t("ul",[t("li",[e._v("这段代码作为宏任务，进入主线程。")]),e._v(" "),t("li",[e._v("先遇到 setTimeout，那么将其回调函数注册后分发到宏任务 Event Queue。(注册过程与上同，下文不再描述)")]),e._v(" "),t("li",[e._v("接下来遇到了 Promise，new Promise 立即执行，then 函数分发到微任务 Event Queue。")]),e._v(" "),t("li",[e._v("遇到 console.log()，立即执行。")]),e._v(" "),t("li",[e._v("好啦，整体代码 script 作为第一个宏任务执行结束，看看有哪些微任务？我们发现了 then 在微任务 Event Queue 里面，执行。")]),e._v(" "),t("li",[e._v("ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务 Event Queue 开始。我们发现了宏任务 Event Queue 中 setTimeout 对应的回调函数，立即执行。")]),e._v(" "),t("li",[e._v("结束。")])]),e._v(" "),t("p",[e._v("事件循环，宏任务，微任务的关系如图所示：\n"),t("img",{attrs:{src:"https://tangmengcheng.github.io/assets/img/5.c538b4cd.png",alt:"cmd-markdown-logo"}})]),e._v(" "),t("p",[e._v("我们来分析一段较复杂的代码，看看否真的掌握了 js 的执行机制：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("console.log('1')\n\nsetTimeout(function() {\n  console.log('2')\n  process.nextTick(function() {\n    console.log('3')\n  })\n  new Promise(function(resolve) {\n    console.log('4')\n    resolve()\n  }).then(function() {\n    console.log('5')\n  })\n})\nprocess.nextTick(function() {\n  console.log('6')\n})\nnew Promise(function(resolve) {\n  console.log('7')\n  resolve()\n}).then(function() {\n  console.log('8')\n})\n\nsetTimeout(function() {\n  console.log('9')\n  process.nextTick(function() {\n    console.log('10')\n  })\n  new Promise(function(resolve) {\n    console.log('11')\n    resolve()\n  }).then(function() {\n    console.log('12')\n  })\n})\n")])])]),t("p",[e._v("第一轮事件循环流程分析如下：")]),e._v(" "),t("ul",[t("li",[e._v("整体 script 作为第一个宏任务进入主线程，遇到 console.log，输出 1。")]),e._v(" "),t("li",[e._v("遇到 setTimeout，其回调函数被分发到宏任务 Event Queue 中。我们暂且记为 setTimeout1。")]),e._v(" "),t("li",[e._v("遇到 process.nextTick()，其回调函数被分发到微任务 Event Queue 中。我们记为 process1。")]),e._v(" "),t("li",[e._v("遇到 Promise，new Promise 直接执行，输出 7。then 被分发到微任务 Event Queue 中。我们记为 then1。")]),e._v(" "),t("li",[e._v("又遇到了 setTimeout，其回调函数被分发到宏任务 Event Queue 中，我们记为 setTimeout2。")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://tangmengcheng.github.io/assets/img/4.41bf28e1.png",alt:"cmd-markdown-logo"}})]),e._v(" "),t("ul",[t("li",[e._v("上表是第一轮事件循环宏任务结束时各 Event Queue 的情况，此时已经输出了 1 和 7。")]),e._v(" "),t("li",[e._v("我们发现了 process1 和 then1 两个微任务。")]),e._v(" "),t("li",[e._v("执行 process1,输出 6。")]),e._v(" "),t("li",[e._v("执行 then1，输出 8。")])]),e._v(" "),t("p",[e._v("好了，第一轮事件循环正式结束，这一轮的结果是输出 1，7，6，8。那么第二轮时间循环从 setTimeout1 宏任务开始：")]),e._v(" "),t("ul",[t("li",[e._v("首先输出 2。接下来遇到了 process.nextTick()，同样将其分发到微任务 Event Queue 中，记为 process2。new Promise 立即执行输出 4，then 也分发到微任务 Event Queue 中，记为 then2。")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://tangmengcheng.github.io/assets/img/3.b0c48c3d.png",alt:"cmd-markdown-logo"}})]),e._v(" "),t("ul",[t("li",[e._v("第二轮事件循环宏任务结束，我们发现有 process2 和 then2 两个微任务可以执行。")]),e._v(" "),t("li",[e._v("输出 3")]),e._v(" "),t("li",[e._v("输出 5。")]),e._v(" "),t("li",[e._v("第二轮事件循环结束，第二轮输出 2，4，3，5。")]),e._v(" "),t("li",[e._v("第三轮事件循环开始，此时只剩 setTimeout2 了，执行。")]),e._v(" "),t("li",[e._v("直接输出 9。")]),e._v(" "),t("li",[e._v("将 process.nextTick()分发到微任务 Event Queue 中。记为 process3。")]),e._v(" "),t("li",[e._v("直接执行 new Promise，输出 11。")]),e._v(" "),t("li",[e._v("将 then 分发到微任务 Event Queue 中，记为 then3。")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://tangmengcheng.github.io/assets/img/2.2acacac1.png",alt:"cmd-markdown-logo"}})]),e._v(" "),t("ul",[t("li",[e._v("第三轮事件循环宏任务执行结束，执行两个微任务 process3 和 then3")]),e._v(" "),t("li",[e._v("输出 10")]),e._v(" "),t("li",[e._v("输出 12")]),e._v(" "),t("li",[e._v("第三轮事件循环结束，第三轮输出 9，11，10，12。")])]),e._v(" "),t("p",[e._v("整段代码，共进行了三次事件循环，完整的输出为 1，7，6，8，2，4，3，5，9，11，10，12。")]),e._v(" "),t("p",[e._v("注意：node 环境下的事件监听依赖 libuv 与前端环境不完全相同，输出顺序可能会有误差。")]),e._v(" "),t("h2",{attrs:{id:"最后"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#最后"}},[e._v("#")]),e._v(" 最后")]),e._v(" "),t("p",[e._v("1、js 的异步")]),e._v(" "),t("p",[e._v("我们从最开头就说 javascript 是一门单线程语言，不管是什么新框架新语法糖实现的所谓异步，其实都是用同步的方法去模拟的，牢牢把握住单线程这点非常重要。")]),e._v(" "),t("p",[e._v("2、事件循环 Event Loop")]),e._v(" "),t("p",[e._v("事件循环是 js 实现异步的一种方法，也是 js 的执行机制。")]),e._v(" "),t("p",[e._v("3、javascript 的执行和运行")]),e._v(" "),t("p",[e._v("执行和运行有很大的区别，javascript 在不同的环境下，比如 node，浏览器，Ringo 等等，执行方式是不同的。而运行大多指 javascript 解析引擎，是统一的。")]),e._v(" "),t("p",[e._v("4、setImmediate")]),e._v(" "),t("p",[e._v("微任务和宏任务还有很多种类，比如 setImmediate 等等，执行都是有共同点的，有兴趣的同学可以自行了解。")]),e._v(" "),t("p",[e._v("5、最后的最后")]),e._v(" "),t("ul",[t("li",[e._v("javascript 是一门单线程语言")]),e._v(" "),t("li",[e._v("Event Loop 是 javascript 的执行机制")])])])}],!1,null,null,null);t.default=v.exports}}]);