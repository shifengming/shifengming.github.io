(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{223:function(e,t,a){"use strict";a.r(t);var s=a(0),n=Object(s.a)({},(function(){this._self._c;return this._m(0)}),[function(){var e=this,t=e._self._c;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"重点题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#重点题"}},[e._v("#")]),e._v(" 重点题")]),e._v(" "),t("h2",{attrs:{id:"vue生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue生命周期"}},[e._v("#")]),e._v(" vue生命周期")]),e._v(" "),t("p",[e._v("什么是Vue生命周期？")]),e._v(" "),t("p",[e._v("Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期")]),e._v(" "),t("p",[e._v("Vue生命周期的作用是什么？")]),e._v(" "),t("p",[e._v("它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑")]),e._v(" "),t("p",[e._v("Vue生命周期总共有几个阶段？")]),e._v(" "),t("p",[e._v("它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后")]),e._v(" "),t("p",[e._v("第一次页面加载会触发哪几个钩子？")]),e._v(" "),t("p",[e._v("第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子")]),e._v(" "),t("p",[e._v("DOM渲染在哪个周期中就已经完成？")]),e._v(" "),t("p",[e._v("DOM 渲染在 mounted 中就已经完成了")]),e._v(" "),t("p",[e._v("每个生命周期适合哪些场景？")]),e._v(" "),t("p",[e._v("生命周期钩子的一些使用方法：")]),e._v(" "),t("p",[e._v("beforecreate : 可以在这加个loading事件，在加载实例时触发")]),e._v(" "),t("p",[e._v("created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用")]),e._v(" "),t("p",[e._v("mounted : 挂载元素，获取到DOM节点")]),e._v(" "),t("p",[e._v("updated : 如果对数据统一处理，在这里写上相应函数")]),e._v(" "),t("p",[e._v("beforeDestroy : 可以做一个确认停止事件的确认框")]),e._v(" "),t("p",[e._v("nextTick : 更新数据后立即操作dom")]),e._v(" "),t("h2",{attrs:{id:"v-show与v-if区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v-show与v-if区别"}},[e._v("#")]),e._v(" v-show与v-if区别")]),e._v(" "),t("p",[e._v("v-show是css切换，v-if是完整的销毁和重新创建")]),e._v(" "),t("p",[e._v("使用 频繁切换时用v-show，运行时较少改变时用v-if")]),e._v(" "),t("p",[e._v("v-if=‘false’ v-if是条件渲染，当false的时候不会渲染")]),e._v(" "),t("h2",{attrs:{id:"开发中常用的指令有哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#开发中常用的指令有哪些"}},[e._v("#")]),e._v(" 开发中常用的指令有哪些")]),e._v(" "),t("p",[e._v("v-model :一般用在表达输入，很轻松的实现表单控件和数据的双向绑定")]),e._v(" "),t("p",[e._v("v-html: 更新元素的 innerHTML")]),e._v(" "),t("p",[e._v("v-show 与 v-if: 条件渲染, 注意二者区别")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("使用了v-if的时候，如果值为false，那么页面将不会有这个html标签生成\nv-show则是不管值为true还是false，html元素都会存在，只是CSS中的display显示或隐藏\n")])])]),t("p",[e._v("v-on : click: 可以简写为@click,@绑定一个事件。如果事件触发了，就可以指定事件的处理函数\nv-for:基于源数据多次渲染元素或模板块\nv-bind: 当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('语法：v-bind:title="msg" 简写：:title="msg"\n')])])]),t("h2",{attrs:{id:"绑定class的数组用法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#绑定class的数组用法"}},[e._v("#")]),e._v(" 绑定class的数组用法")]),e._v(" "),t("p",[e._v("对象方法 v-bind:class=\"{'orange': isRipe, 'green': isNotRipe}\"")]),e._v(" "),t("p",[e._v('数组方法  v-bind:class="[class1, class2]"')]),e._v(" "),t("p",[e._v("行内 v-bind:style=\"{color: color, fontSize: fontSize+'px' }\"")]),e._v(" "),t("h2",{attrs:{id:"组件之间的传值通信"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组件之间的传值通信"}},[e._v("#")]),e._v(" 组件之间的传值通信")]),e._v(" "),t("p",[e._v("父组件给子组件传值")]),e._v(" "),t("blockquote",[t("p",[e._v("使用props，父组件可以使用props向子组件传递数据")])]),e._v(" "),t("p",[e._v("父组件vue模板father.vue")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<template>\n    <child :msg=\"message\"></child>\n</template>\n\n<script>\nimport child from './child.vue';\nexport default {\n    components: {\n        child\n    },\n    data () {\n        return {\n            message: 'father message';\n        }\n    }\n}\n<\/script>\n")])])]),t("p",[e._v("子组件vue模板child.vue:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<template>\n    <div>{{msg}}</div>\n</template>\n\n<script>\nexport default {\n    props: {\n        msg: {\n            type: String,\n            required: true\n        }\n    }\n}\n<\/script>\n")])])]),t("p",[e._v("子组件向父组件通信")]),e._v(" "),t("blockquote",[t("p",[e._v("父组件向子组件传递事件方法，子组件通过$emit触发事件，回调给父组件")])]),e._v(" "),t("p",[e._v("父组件vue模板father.vue:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<template>\n    <child @msgFunc=\"func\"></child>\n</template>\n\n<script>\nimport child from './child.vue';\nexport default {\n    components: {\n        child\n    },\n    methods: {\n        func (msg) {\n            console.log(msg);\n        }\n    }\n}\n<\/script>\n")])])]),t("p",[e._v("子组件vue模板child.vue:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<template>\n    <button @click=\"handleClick\">点我</button>\n</template>\n\n<script>\nexport default {\n    props: {\n        msg: {\n            type: String,\n            required: true\n        }\n    },\n    methods () {\n        handleClick () {\n            //........\n            this.$emit('msgFunc');\n        }\n    }\n}\n<\/script>\n")])])]),t("p",[e._v("非父子，兄弟组件之间通信")]),e._v(" "),t("blockquote",[t("p",[e._v("可以通过实例一个vue实例Bus作为媒介，要相互通信的兄弟组件之中，都引入Bus，然后通过分别调用Bus事件触发和监听来实现通信和参数传递")])]),e._v(" "),t("p",[e._v("Bus.js可以是这样:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("import Vue from 'vue'\nexport default new Vue()\n")])])]),t("p",[e._v("在需要通信的组件都引入Bus.js:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<template>\n\t<button @click=\"toBus\">子组件传给兄弟组件</button>\n</template>\n\n<script>\nimport Bus from '../common/js/bus.js'\nexport default{\n\tmethods: {\n\t    toBus () {\n\t        Bus.$emit('on', '来自兄弟组件')\n\t    }\n\t  }\n}\n<\/script>\n")])])]),t("p",[e._v("另一个组件也import Bus.js 在钩子函数中监听on事件")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("import Bus from '../common/js/bus.js'\nexport default {\n    data() {\n      return {\n        message: ''\n      }\n    },\n    mounted() {\n       Bus.$on('on', (msg) => {\n         this.message = msg\n       })\n     }\n   }\n")])])]),t("h2",{attrs:{id:"路由跳转方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#路由跳转方式"}},[e._v("#")]),e._v(" 路由跳转方式")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1，<router-link to='home'> router-link标签会渲染为<a>标签，咋填template中的跳转都是这种；\n\n2，另一种是编程是导航 也就是通过js跳转 比如 router.push('/home')\n")])])]),t("h2",{attrs:{id:"mvvm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mvvm"}},[e._v("#")]),e._v(" MVVM")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("M - Model，Model 代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑\n\nV - View，View 代表 UI 组件，它负责将数据模型转化为 UI 展现出来\n\nVM - ViewModel，ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步 View 和 Model 的对象，连接 Model 和 View\n")])])]),t("h2",{attrs:{id:"computed和watch有什么区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#computed和watch有什么区别"}},[e._v("#")]),e._v(" computed和watch有什么区别?")]),e._v(" "),t("p",[e._v("computed:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1. computed是计算属性,也就是计算值,它更多用于计算值的场景\n2. computed具有缓存性,computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时才会重新调用对应的getter来计算\n3. computed适用于计算比较消耗性能的计算场景\n")])])]),t("p",[e._v("watch:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1. 更多的是「观察」的作用,类似于某些数据的监听回调,用于观察props $emit或者本组件的值,当数据变化时来执行回调进行后续操作\n2. 无缓存性，页面重新渲染时值不变化也会执行\n")])])]),t("p",[e._v("小结:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1. 当我们要进行数值计算,而且依赖于其他数据，那么把这个数据设计为computed\n2. 如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化\n")])])]),t("h2",{attrs:{id:"key"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#key"}},[e._v("#")]),e._v(" key")]),e._v(" "),t("p",[e._v("key是为Vue中的vnode标记的唯一id，通过这个key，我们的diff操作可以 更准确、更快速")]),e._v(" "),t("p",[e._v("准确:")]),e._v(" "),t("p",[e._v("如果不加key,那么vue会选择复用节点(Vue的就地更新策略),导致之前节点的状态被保留下来，会产生一系列的bug")]),e._v(" "),t("p",[e._v("快速:")]),e._v(" "),t("p",[e._v("key的唯一性可以被Map数据结构充分利用")]),e._v(" "),t("h2",{attrs:{id:"组件中的data为什么是函数？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组件中的data为什么是函数？"}},[e._v("#")]),e._v(" 组件中的data为什么是函数？")]),e._v(" "),t("p",[e._v("为什么组件中的data必须是一个函数，然后return一个对象，而new Vue实例里，data可以直接是一个对象？")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// data\ndata() {\n  return {\n\tmessage: \"子组件\",\n\tchildName:this.name\n  }\n}\n\n// new Vue\nnew Vue({\n  el: '#app',\n  router,\n  template: '<App/>',\n  components: {App}\n})\n")])])]),t("p",[e._v("因为组件是用来复用的，JS里对象是引用关系，这样作用域没有隔离，而new Vue的实例，是不会被复用的，因此不存在引用对象问题")]),e._v(" "),t("h2",{attrs:{id:"class-与-style-如何动态绑定？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#class-与-style-如何动态绑定？"}},[e._v("#")]),e._v(" Class 与 Style 如何动态绑定？")]),e._v(" "),t("blockquote",[t("p",[e._v("Class 可以通过对象语法和数组语法进行动态绑定：")])]),e._v(" "),t("p",[e._v("对象语法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<div v-bind:class=\"{ active: isActive, 'text-danger': hasError }\"></div>\n\ndata: {\n  isActive: true,\n  hasError: false\n}\n")])])]),t("p",[e._v("数组语法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<div v-bind:class=\"[isActive ? activeClass : '', errorClass]\"></div>\n\ndata: {\n  activeClass: 'active',\n  errorClass: 'text-danger'\n}\n")])])]),t("blockquote",[t("p",[e._v("Style 也可以通过对象语法和数组语法进行动态绑定：")])]),e._v(" "),t("p",[e._v("对象语法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<div v-bind:style=\"{ color: activeColor, fontSize: fontSize + 'px' }\"></div>\n\ndata: {\n  activeColor: 'red',\n  fontSize: 30\n}\n")])])]),t("p",[e._v("数组语法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<div v-bind:style=\"[styleColor, styleSize]\"></div>\n\ndata: {\n  styleColor: {\n     color: 'red'\n   },\n  styleSize:{\n     fontSize:'23px'\n  }\n}\n")])])]),t("h2",{attrs:{id:"vue的单项数据流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue的单项数据流"}},[e._v("#")]),e._v(" vue的单项数据流")]),e._v(" "),t("p",[e._v("所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解")]),e._v(" "),t("p",[e._v("额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改")]),e._v(" "),t("p",[e._v("有两种常见的试图改变一个 prop 的情形 :")]),e._v(" "),t("p",[e._v("这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用")]),e._v(" "),t("blockquote",[t("p",[e._v("在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("props: ['initialCounter'],\ndata: function () {\n  return {\n    counter: this.initialCounter\n  }\n}\n")])])]),t("p",[e._v("这个 prop 以一种原始的值传入且需要进行转换")]),e._v(" "),t("blockquote",[t("p",[e._v("在这种情况下，最好使用这个 prop 的值来定义一个计算属性")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("props: ['size'],\ncomputed: {\n  normalizedSize: function () {\n    return this.size.trim().toLowerCase()\n  }\n}\n")])])]),t("h2",{attrs:{id:"keep-alive"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#keep-alive"}},[e._v("#")]),e._v(" keep-alive")]),e._v(" "),t("p",[e._v("keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：")]),e._v(" "),t("ul",[t("li",[e._v("一般结合路由和动态组件一起使用，用于缓存组件；")]),e._v(" "),t("li",[e._v("提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；")]),e._v(" "),t("li",[e._v("对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。")])]),e._v(" "),t("h2",{attrs:{id:"v-model-的原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v-model-的原理"}},[e._v("#")]),e._v(" v-model 的原理")]),e._v(" "),t("p",[e._v("vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：")]),e._v(" "),t("ul",[t("li",[e._v("text 和 textarea 元素使用 value 属性和 input 事件；")]),e._v(" "),t("li",[e._v("checkbox 和 radio 使用 checked 属性和 change 事件；")]),e._v(" "),t("li",[e._v("select 字段将 value 作为 prop 并将 change 作为事件;")])]),e._v(" "),t("p",[e._v("以 input 表单元素为例：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<input v-model='something'>\n")])])]),t("p",[e._v("相当于")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<input v-bind:value="something" v-on:input="something = $event.target.value">\n')])])]),t("p",[e._v("如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("父组件：\n<ModelChild v-model=\"message\"></ModelChild>\n\n子组件：\n<div>{{value}}</div>\n\nprops:{\n    value: String\n},\nmethods: {\n  test1(){\n     this.$emit('input', '小红')\n  },\n},\n")])])]),t("h2",{attrs:{id:"nexttick"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nexttick"}},[e._v("#")]),e._v(" nextTick()")]),e._v(" "),t("p",[e._v("在下次DOM更新循环结束之后执行延迟回调。在修改数据之后，立即使用的这个回调函数，获取更新后的DOM")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 修改数据\nvm.msg = 'Hello'\n// DOM 还未更新\nVue.nextTick(function () {\n  // DOM 更新\n})\n")])])]),t("h2",{attrs:{id:"vue插槽"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue插槽"}},[e._v("#")]),e._v(" vue插槽")]),e._v(" "),t("p",[e._v("个人觉得这篇文章写的还可以：https://www.cnblogs.com/chinabin1993/p/9115396.html")]),e._v(" "),t("p",[e._v("单个插槽")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("当子组件模板只有一个没有属性的插槽时，\n父组件传入的整个内容片段将插入到插槽所在的 DOM 位置，\n并替换掉插槽标签本身\n")])])]),t("p",[e._v("命名插槽")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("solt元素可以用一个特殊的特性name来进一步配置如何分发内容。\n多个插槽可以有不同的名字。 这样可以将父组件模板中 slot 位置，\n和子组件 slot 元素产生关联，便于插槽内容对应传递\n")])])]),t("p",[e._v("作用域插槽")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("可以访问组件内部数据的可复用插槽(reusable slot)\n在父级中，具有特殊特性 slot-scope 的<template> 元素必须存在，\n表示它是作用域插槽的模板。slot-scope 的值将被用作一个临时变量名，\n此变量接收从子组件传递过来的 prop 对象\n")])])]),t("h2",{attrs:{id:"vue-router有哪几种导航钩子"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-router有哪几种导航钩子"}},[e._v("#")]),e._v(" vue-router有哪几种导航钩子")]),e._v(" "),t("p",[e._v("第一种：是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截")]),e._v(" "),t("p",[e._v("第二种：组件内的钩子")]),e._v(" "),t("p",[e._v("第三种：单独路由独享组件")]),e._v(" "),t("h2",{attrs:{id:"vuex"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vuex"}},[e._v("#")]),e._v(" vuex")]),e._v(" "),t("p",[e._v("vuex是什么？")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("vuex 就是一个仓库，仓库里放了很多对象。其中 state 就是数据源存放地，对应于一般 vue 对象里面的 data\n\nstate 里面存放的数据是响应式的，vue 组件从 store 读取数据，若是 store 中的数据发生改变，依赖这相数据的组件也会发生更新\n\n它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性\n")])])]),t("p",[e._v("Vuex有5种属性: 分别是 state、getter、mutation、action、module;")]),e._v(" "),t("p",[e._v("state")]),e._v(" "),t("p",[e._v("Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据")]),e._v(" "),t("p",[e._v("mutations")]),e._v(" "),t("p",[e._v("mutations定义的方法动态修改Vuex 的 store 中的状态或数据")]),e._v(" "),t("p",[e._v("getters")]),e._v(" "),t("p",[e._v("类似vue的计算属性，主要用来过滤一些数据")]),e._v(" "),t("p",[e._v("action")]),e._v(" "),t("p",[e._v("actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action")]),e._v(" "),t("p",[e._v("总结")]),e._v(" "),t("p",[e._v("vuex 一般用于中大型 web 单页应用中对应用的状态进行管理，对于一些组件间关系较为简单的小型应用，使用 vuex 的必要性不是很大，因为完全可以用组件 prop 属性或者事件来完成父子组件之间的通信，vuex 更多地用于解决跨组件通信以及作为数据中心集中式存储数据")]),e._v(" "),t("h2",{attrs:{id:"你有对-vue-项目进行哪些优化？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#你有对-vue-项目进行哪些优化？"}},[e._v("#")]),e._v(" 你有对 Vue 项目进行哪些优化？")]),e._v(" "),t("p",[e._v("代码层面的优化")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("v-if 和 v-show 区分使用场景\ncomputed 和 watch  区分使用场景\nv-for 遍历必须为 item 添加 key，且避免同时使用 v-if\n长列表性能优化\n事件的销毁\n图片资源懒加载\n路由懒加载\n第三方插件的按需引入\n优化无限列表性能\n服务端渲染 SSR or 预渲染\n")])])]),t("p",[e._v("Webpack 层面的优化")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Webpack 对图片进行压缩\n减少 ES6 转为 ES5 的冗余代码\n提取公共代码\n模板预编译\n提取组件的 CSS\n优化 SourceMap\n构建结果输出分析\nVue 项目的编译优化\n")])])]),t("p",[e._v("基础的 Web 技术的优化")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("开启 gzip 压缩\n浏览器缓存\nCDN 的使用\n使用 Chrome Performance 查找性能瓶颈\n")])])])])}],!1,null,null,null);t.default=n.exports}}]);