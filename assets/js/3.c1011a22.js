(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{169:function(t,s,e){t.exports=e.p+"assets/img/contentBox.e4ba9254.png"},170:function(t,s,e){t.exports=e.p+"assets/img/borderBox.e552b1c8.png"},198:function(t,s,e){"use strict";e.r(s);var o=[function(){var t=this,s=t._self._c;return s("div",{staticClass:"content"},[s("h1",{attrs:{id:"css盒子模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#css盒子模型"}},[t._v("#")]),t._v(" CSS盒子模型")]),t._v(" "),s("h2",{attrs:{id:"盒子模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#盒子模型"}},[t._v("#")]),t._v(" 盒子模型")]),t._v(" "),s("p",[t._v("盒模型分为标准盒模型和怪异盒模型(IE模型)")]),t._v(" "),s("ul",[s("li",[t._v("box-sizing：content-box   //标准盒模型")]),t._v(" "),s("li",[t._v("box-sizing：border-box    //怪异盒模型")])]),t._v(" "),s("p",[s("img",{attrs:{src:e(169),alt:"cmd-markdown-logo"}}),t._v(" "),s("img",{attrs:{src:e(170),alt:"cmd-markdown-logo"}})]),t._v(" "),s("p",[t._v("由图可得：盒模型的宽高只是内容（content）的宽高，而在IE模型中盒模型的宽高是内容(content)+填充(padding)+边框(border)的总宽高")]),t._v(" "),s("h2",{attrs:{id:"js如何设置获取盒模型对应的宽和高"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js如何设置获取盒模型对应的宽和高"}},[t._v("#")]),t._v(" JS如何设置获取盒模型对应的宽和高")]),t._v(" "),s("p",[t._v("通过JS获取盒模型对应的宽和高，有以下几种方法：")]),t._v(" "),s("p",[t._v("1、dom.style.width/height 这种方式只能取到dom元素内联样式所设置的宽高，也就是说如果该节点的样式是在style标签中或外联的CSS文件中设置的话，通过这种方法是获取不到dom的宽高的")]),t._v(" "),s("p",[t._v("2、dom.currentStyle.width/height 这种方式获取的是在页面渲染完成后的结果，就是说不管是哪种方式设置的样式，都能获取到。但这种方式只有IE浏览器支持。")]),t._v(" "),s("p",[t._v("3、window.getComputedStyle(dom).width/heigth 这种方式的原理和2是一样的，这个可以兼容更多的浏览器，通用性好一些。")]),t._v(" "),s("p",[t._v("4、dom.getBoundingClientRect().width/height 这种方式是根据元素在视窗中的绝对位置来获取宽高的")]),t._v(" "),s("p",[t._v("5、dom.offsetWidth/offsetHeight 这个就没什么好说的了，最常用的，也是兼容最好的。")])])}],n=e(0),i=Object(n.a)({},(function(){this._self._c;return this._m(0)}),o,!1,null,null,null);s.default=i.exports}}]);