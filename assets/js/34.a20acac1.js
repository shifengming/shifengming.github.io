(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{207:function(e,n,s){"use strict";s.r(n);var t=s(0),r=Object(t.a)({},(function(){var e=this,n=e.$createElement,s=e._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"promise对象的使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise对象的使用"}},[e._v("#")]),e._v(" promise对象的使用")]),e._v(" "),s("h2",{attrs:{id:"什么是异步编程？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是异步编程？"}},[e._v("#")]),e._v(" 什么是异步编程？")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("从服务器获取数据，这个过程就叫做异步编程")])]),e._v(" "),s("li",[s("p",[e._v("在node.js中去读取文件，这个过程也是异步的")])])]),e._v(" "),s("h2",{attrs:{id:"关于异步的解决方案目前有四种："}},[s("a",{staticClass:"header-anchor",attrs:{href:"#关于异步的解决方案目前有四种："}},[e._v("#")]),e._v(" 关于异步的解决方案目前有四种：")]),e._v(" "),s("ul",[s("li",[e._v("callback(回调函数)")]),e._v(" "),s("li",[e._v("generato + co库")]),e._v(" "),s("li",[e._v("promise")]),e._v(" "),s("li",[e._v("async+await")])]),e._v(" "),s("h1",{attrs:{id:"学习之前"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#学习之前"}},[e._v("#")]),e._v(" 学习之前")]),e._v(" "),s("p",[e._v("在学习之前我们需要弄懂以下的：")]),e._v(" "),s("ul",[s("li",[e._v("了解Promise")]),e._v(" "),s("li",[e._v("es6   (主要是es6的箭头函数和es6的类)")]),e._v(" "),s("li",[e._v("this的指向问题")]),e._v(" "),s("li",[e._v("关于promise/A+规范")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("参考文档：https://promisesaplus.com/\n")])])]),s("h1",{attrs:{id:"术语"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#术语"}},[e._v("#")]),e._v(" 术语")]),e._v(" "),s("h2",{attrs:{id:"解决（fulfill）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解决（fulfill）"}},[e._v("#")]),e._v(" 解决（fulfill）")]),e._v(" "),s("p",[e._v("指一个 promise 成功时进行的一系列操作，如状态的改变、回调的执行。虽然规范中用 fulfill 来表示解决，但在后世的 promise 实现多以 resolve 来指代之")]),e._v(" "),s("h2",{attrs:{id:"拒绝（reject）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#拒绝（reject）"}},[e._v("#")]),e._v(" 拒绝（reject）")]),e._v(" "),s("p",[e._v("指一个 promise失败时进行的一系列操作")]),e._v(" "),s("h2",{attrs:{id:"终值（eventual-value）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#终值（eventual-value）"}},[e._v("#")]),e._v(" 终值（eventual value）")]),e._v(" "),s("p",[e._v("所谓终值，指的是 promise 被解决时传递给解决回调的值，由于 promise 有一次性的特征，因此当这个值被传递时，标志着 promise 等待态的结束，故称之终值，有时也直接简称为值（value）")]),e._v(" "),s("h2",{attrs:{id:"据因（reason）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#据因（reason）"}},[e._v("#")]),e._v(" 据因（reason）")]),e._v(" "),s("p",[e._v("也就是拒绝原因，指在 promise 被拒绝时传递给拒绝回调的值")]),e._v(" "),s("h2",{attrs:{id:"promise"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[e._v("#")]),e._v(" Promise")]),e._v(" "),s("p",[e._v("promise是一个拥有then方法的对象或函数，其行为符合本规范")]),e._v(" "),s("h2",{attrs:{id:"thenable"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#thenable"}},[e._v("#")]),e._v(" thenable")]),e._v(" "),s("p",[e._v("是一个定义了then方法的对象或函数")]),e._v(" "),s("h2",{attrs:{id:"值（value）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#值（value）"}},[e._v("#")]),e._v(" 值（value）")]),e._v(" "),s("p",[e._v("指任何JavaScript的合法值（包括undefined、thenable和promise）")]),e._v(" "),s("h2",{attrs:{id:"异常（exception）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#异常（exception）"}},[e._v("#")]),e._v(" 异常（exception）")]),e._v(" "),s("p",[e._v("是适用throw语句抛出的一个值")]),e._v(" "),s("h1",{attrs:{id:"异步回调"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#异步回调"}},[e._v("#")]),e._v(" 异步回调")]),e._v(" "),s("h2",{attrs:{id:"回调地域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#回调地域"}},[e._v("#")]),e._v(" 回调地域")]),e._v(" "),s("p",[e._v("在需要多个操作的时候，会导致多个回调函数嵌套，导致代码不够直观，就是常说的回调地狱")]),e._v(" "),s("h2",{attrs:{id:"并行结果"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#并行结果"}},[e._v("#")]),e._v(" 并行结果")]),e._v(" "),s("p",[e._v("如果几个异步操作之间并没有前后顺序之分,但需要等多个异步操作都完成后才能执行后续的任务，无法实现并行节约时间")]),e._v(" "),s("h1",{attrs:{id:"promise理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise理解"}},[e._v("#")]),e._v(" promise理解")]),e._v(" "),s("p",[e._v("Promise本意是承诺，在程序中的意思就是承诺我过一段时间后会给你一个结果：")]),e._v(" "),s("p",[e._v("什么时候会用到过一段时间？")]),e._v(" "),s("p",[e._v("是异步操作")]),e._v(" "),s("p",[e._v("异步是指可能比较长时间才有结果的才做，例如网络请求、读取本地文件等")]),e._v(" "),s("h1",{attrs:{id:"promise的状态"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise的状态"}},[e._v("#")]),e._v(" Promise的状态")]),e._v(" "),s("blockquote",[s("p",[e._v("一个Promise的当前状态必须为以下三种状态中的一种")])]),e._v(" "),s("h2",{attrs:{id:"等待态（pending）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#等待态（pending）"}},[e._v("#")]),e._v(" 等待态（Pending）")]),e._v(" "),s("blockquote",[s("p",[e._v("处于等待态时，promise需满足以下条件：")])]),e._v(" "),s("p",[e._v("可以迁移至执行态或拒绝态")]),e._v(" "),s("h2",{attrs:{id:"执行态（fulfilled）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#执行态（fulfilled）"}},[e._v("#")]),e._v(" 执行态（Fulfilled）")]),e._v(" "),s("blockquote",[s("p",[e._v("处于执行态时，promise 需满足以下条件：")])]),e._v(" "),s("p",[e._v("不能迁移至其他任何状态")]),e._v(" "),s("p",[e._v("必须拥有一个不可变的终值")]),e._v(" "),s("h2",{attrs:{id:"拒绝态（rejected）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#拒绝态（rejected）"}},[e._v("#")]),e._v(" 拒绝态（Rejected）")]),e._v(" "),s("blockquote",[s("p",[e._v("处于拒绝态时，promise需要满足以下条件")])]),e._v(" "),s("p",[e._v("不能迁移至其他任何状态")]),e._v(" "),s("p",[e._v("必须拥有一个不可变的据因")]),e._v(" "),s("h1",{attrs:{id:"then方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#then方法"}},[e._v("#")]),e._v(" Then方法")]),e._v(" "),s("blockquote",[s("p",[e._v("一个promise必须提供一个then方法以访问其当前值、终值和据因")])]),e._v(" "),s("p",[s("strong",[e._v("promise的then方法接受两个参数：")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("promise.then(onFulfilled, onRejected)\n")])])]),s("p",[s("strong",[e._v("onFulfilled 和 onRejected 都是可选参数")])]),e._v(" "),s("ul",[s("li",[e._v("如果onFullfilled不是函数，其必须被忽略")]),e._v(" "),s("li",[e._v("如果onRejected不是函数，其必须被忽略")])]),e._v(" "),s("h2",{attrs:{id:"onfulfilled特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#onfulfilled特性"}},[e._v("#")]),e._v(" onFulfilled特性")]),e._v(" "),s("blockquote",[s("p",[e._v("如果onFulfilled是函数：")])]),e._v(" "),s("ul",[s("li",[e._v("当promise执行结束后其必须被调用，其第一个参数为promise的终值")]),e._v(" "),s("li",[e._v("在promise执行结束前其不可被调用")]),e._v(" "),s("li",[e._v("其调用次数不可超过一次")])]),e._v(" "),s("h2",{attrs:{id:"onrejected特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#onrejected特性"}},[e._v("#")]),e._v(" onRejected特性")]),e._v(" "),s("blockquote",[s("p",[e._v("如果onRejected是函数：")])]),e._v(" "),s("ul",[s("li",[e._v("当 promise 被拒绝执行后其必须被调用，其第一个参数为 promise 的据因")]),e._v(" "),s("li",[e._v("在 promise 被拒绝执行前其不可被调用")]),e._v(" "),s("li",[e._v("其调用次数不可超过一次")])]),e._v(" "),s("h2",{attrs:{id:"调用时机"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#调用时机"}},[e._v("#")]),e._v(" 调用时机")]),e._v(" "),s("p",[e._v("onFulfilled 和 onRejected 只有在执行环境堆栈仅包含平台代码时才可被调用")]),e._v(" "),s("h2",{attrs:{id:"调用要求"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#调用要求"}},[e._v("#")]),e._v(" 调用要求")]),e._v(" "),s("p",[e._v("onFulfilled 和 onRejected 必须被作为函数调用（即没有 this 值）")]),e._v(" "),s("h2",{attrs:{id:"多次调用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多次调用"}},[e._v("#")]),e._v(" 多次调用")]),e._v(" "),s("blockquote",[s("p",[e._v("then 方法可以被同一个promise调用多次")])]),e._v(" "),s("ul",[s("li",[s("p",[e._v("当 promise 成功执行时，所有 onFulfilled 需按照其注册顺序依次回调")])]),e._v(" "),s("li",[s("p",[e._v("当 promise 被拒绝执行时，所有的 onRejected 需按照其注册顺序依次回调")])])]),e._v(" "),s("h2",{attrs:{id:"返回"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#返回"}},[e._v("#")]),e._v(" 返回")]),e._v(" "),s("p",[e._v("then 方法必须返回一个 promise 对象")]),e._v(" "),s("h1",{attrs:{id:"准备"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#准备"}},[e._v("#")]),e._v(" 准备")]),e._v(" "),s("blockquote",[s("p",[e._v("在开始之前我们需要创建三个文件")])]),e._v(" "),s("ul",[s("li",[e._v("index.js进行原生的Promise演示")]),e._v(" "),s("li",[e._v("promise.js进行自定义的Promise演示")]),e._v(" "),s("li",[e._v("test.js是对promise.js进行测试")])]),e._v(" "),s("h1",{attrs:{id:"promise初体验"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise初体验"}},[e._v("#")]),e._v(" promise初体验")]),e._v(" "),s("h2",{attrs:{id:"一个最基本的promise长什么样？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一个最基本的promise长什么样？"}},[e._v("#")]),e._v(" 一个最基本的Promise长什么样？")]),e._v(" "),s("blockquote",[s("p",[e._v("代码如下：")])]),e._v(" "),s("p",[s("strong",[e._v("index.js")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("new Promise((resolve, reject) => {\n    setTimeout(() => {\n        resolve(1)\n    })\n}).then(value => {\n    console.log('value',value)\n},reason => {\n    console.log('reason',reason)\n})\n")])])]),s("p",[s("strong",[e._v("运行结果：")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("value 1\n")])])]),s("h2",{attrs:{id:"原生的promise它的参数不是函数的时，会发生什么？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#原生的promise它的参数不是函数的时，会发生什么？"}},[e._v("#")]),e._v(" 原生的promise它的参数不是函数的时，会发生什么？")]),e._v(" "),s("blockquote",[s("p",[e._v("代码如下：")])]),e._v(" "),s("p",[s("strong",[e._v("index.js")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("new Promise(1)\n")])])]),s("p",[s("strong",[e._v("promise.js")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("class Promise {\n    constructor(executor){\n        //参数效验\n        if(typeof executor !== 'function'){\n            throw new TypeError('Promise resolver ${executor} is not a function')\n        }\n    }\n}\n")])])]),s("p",[s("strong",[e._v("运行结果：")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("Promise resolver 1 is not a function\n")])])]),s("h2",{attrs:{id:"这是一个最基本的promise"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#这是一个最基本的promise"}},[e._v("#")]),e._v(" 这是一个最基本的promise")]),e._v(" "),s("blockquote",[s("p",[e._v("代码如下")])]),e._v(" "),s("p",[s("strong",[e._v("index.js")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("new Promise((resolve, reject) => {\n    console.log('早上好！')\n        resolve(1)\n})\n")])])]),s("p",[s("strong",[e._v("promise.js")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("class Promise {\n    constructor(executor){\n        //参数效验\n        if(typeof executor !== 'function'){\n            throw new TypeError('Promise resolver ${executor} is not a function')\n        }\n        const resolve = function (){\n\n        }\n        const reject = function (){\n\n        }\n        executor(resolve,reject)\n    }\n}\n")])])]),s("p",[s("strong",[e._v("运行结果：")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("早上好！\n")])])]),s("h2",{attrs:{id:"再把上边代码测试一下"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#再把上边代码测试一下"}},[e._v("#")]),e._v(" 再把上边代码测试一下")]),e._v(" "),s("blockquote",[s("p",[e._v("代码如下：")])]),e._v(" "),s("p",[s("strong",[e._v("promise.js")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("class Promise {\n  constructor(executor){\n      //不能相信用户的输入，所以这里要做参数效验\n      if(typeof executor !== 'function'){\n          throw new TypeError('Promise resolver ${executor} is not a function')\n      }\n      //记录状态和值的改变\n      //初始化值\n      this.value = null //终值\n      this.reason = null //拒因\n      this.state = 'pending' //状态\n\n      const resolve = value => {\n          //成功后的一系列操作（状态的改变，成功回调的执行）\n          if(this.state === 'pending'){\n              //状态进行改变\n              this.state = 'fulfilled'\n              //执行成功的回调，把终值进行赋值\n              this.value = value\n          }\n      }\n      const reject = reason =>{\n          //失败后的一系列操作（状态的改变，失败回调的执行）\n          if(this.state === 'pending'){\n              //状态进行改变\n              this.state = 'rejected'\n              //执行成功的回调，把据因进行赋值\n              this.reason = reason\n          }\n      }\n      executor(resolve,reject)\n  }\n}\nmodule.exports = Promise\n")])])]),s("p",[s("strong",[e._v("test.js")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const Promise = require('./promise.js')\n\nnew Promise((resolve, reject) => {\n    console.log('早上好！')\n        resolve(1)\n})\n")])])]),s("p",[s("strong",[e._v("运行结果：")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("早上好！\n")])])]),s("h1",{attrs:{id:"promise初步实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise初步实现"}},[e._v("#")]),e._v(" promise初步实现")]),e._v(" "),s("h2",{attrs:{id:"把上边的代码进行优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#把上边的代码进行优化"}},[e._v("#")]),e._v(" 把上边的代码进行优化")]),e._v(" "),s("blockquote",[s("p",[e._v("优化后的代码如下")])]),e._v(" "),s("p",[s("strong",[e._v("promise.js")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("class Promise {\n    constructor(executor){\n        //不能相信用户的输入，所以这里要做参数效验\n        if(typeof executor !== 'function'){\n            throw new TypeError('Promise resolver ${executor} is not a function')\n        }\n\n        this.initValue()\n        this.initBind()\n\n        executor(this.resolve,this.reject)\n    }\n    //绑定 this\n    initBind(){\n        this.resolve = this.resolve.bind(this)\n        this.reject = this.reject.bind(this)\n    }\n    //进行代码的优化\n    initValue(){\n        //记录状态和值的改变\n        //初始化值\n        this.value = null //终值\n        this.reason = null //拒因\n        this.state = 'pending' //状态\n    }\n    resolve(value){\n        //成功后的一系列操作（状态的改变，成功回调的执行）\n        if(this.state === 'pending'){\n            //状态进行改变\n            this.state = 'fulfilled'\n            //执行成功的回调，把终值进行赋值\n            this.value = value\n        }\n    }\n    reject(reason){\n        //失败后的一系列操作（状态的改变，失败回调的执行）\n        if(this.state === 'pending'){\n            //状态进行改变\n            this.state = 'rejected'\n            //执行成功的回调，把据因进行赋值\n            this.reason = reason\n        }\n    }\n    then() {}\n}\nmodule.exports = Promise\n")])])]),s("p",[s("strong",[e._v("test.js")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const Promise = require('./promise.js')\n\nnew Promise((resolve, reject) => {\n    console.log('早上好！')\n        resolve(1)\n})\n")])])]),s("p",[s("strong",[e._v("运行结果：")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("早上好！\n")])])]),s("h2",{attrs:{id:"测试通过后，下一步then方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#测试通过后，下一步then方法"}},[e._v("#")]),e._v(" 测试通过后，下一步then方法")]),e._v(" "),s("blockquote",[s("p",[e._v("代码如下：")])]),e._v(" "),s("p",[s("strong",[e._v("promise.js")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("class Promise {\n    constructor(executor){\n        //不能相信用户的输入，所以这里要做参数效验\n        if(typeof executor !== 'function'){\n            throw new TypeError('Promise resolver ${executor} is not a function')\n        }\n\n        this.initValue()\n        this.initBind()\n\n        executor(this.resolve,this.reject)\n    }\n    //绑定 this\n    initBind(){\n        this.resolve = this.resolve.bind(this)\n        this.reject = this.reject.bind(this)\n    }\n    //进行代码的优化\n    initValue(){\n        //记录状态和值的改变\n        //初始化值\n        this.value = null //终值\n        this.reason = null //拒因\n        this.state = 'pending' //状态\n    }\n    resolve(value){\n        //成功后的一系列操作（状态的改变，成功回调的执行）\n        if(this.state === 'pending'){\n            //状态进行改变\n            this.state = 'fulfilled'\n            //执行成功的回调，把终值进行赋值\n            this.value = value\n        }\n    }\n    reject(reason){\n        //失败后的一系列操作（状态的改变，失败回调的执行）\n        if(this.state === 'pending'){\n            //状态进行改变\n            this.state = 'rejected'\n            //执行成功的回调，把据因进行赋值\n            this.reason = reason\n        }\n    }\n    then(onFulfilled, onRejected) {\n        //  参数效验\n        if (typeof onFulfilled !== 'function'){\n            onFulfilled = function(value) {\n                return value\n            }\n        }\n        if (typeof onRejected !== 'function'){\n            onRejected = function(reason){\n                throw reason\n            }\n        }\n        if(this.state === 'fulfilled'){\n            onFulfilled(this.value)\n        }\n        if(this.state === 'rejected'){\n            onRejected(this.reason)\n        }\n    }\n}\nmodule.exports = Promise\n")])])]),s("p",[s("strong",[e._v("test.js")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const Promise = require('./promise.js')\n\nnew Promise((resolve, reject) => {\n    console.log('早上好！')\n        resolve(1)\n}).then(value=> {\n    console.log('value',value)\n},reason => {   \n    console.log('reason',value)\n})\n")])])]),s("p",[s("strong",[e._v("运行结果：")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("早上好！\nvalue 1\n")])])]),s("h2",{attrs:{id:"将上边的代码再次进行优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#将上边的代码再次进行优化"}},[e._v("#")]),e._v(" 将上边的代码再次进行优化")]),e._v(" "),s("blockquote",[s("p",[e._v("代码如下：")])]),e._v(" "),s("p",[s("strong",[e._v("promise.js")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("class Promise {\n    constructor(executor){\n        //不能相信用户的输入，所以这里要做参数效验\n        if(typeof executor !== 'function'){\n            throw new TypeError('Promise resolver ${executor} is not a function')\n        }\n\n        this.initValue()\n        this.initBind()\n\n        executor(this.resolve,this.reject)\n    }\n    //绑定 this\n    initBind(){\n        this.resolve = this.resolve.bind(this)\n        this.reject = this.reject.bind(this)\n    }\n    //进行代码的优化\n    initValue(){\n        //记录状态和值的改变\n        //初始化值\n        this.value = null //终值\n        this.reason = null //拒因\n        this.state = Promise.PENDING //状态\n    }\n    resolve(value){\n        //成功后的一系列操作（状态的改变，成功回调的执行）\n        if(this.state === Promise.PENDING){\n            //状态进行改变\n            this.state = Promise.FULFILLED\n            //执行成功的回调，把终值进行赋值\n            this.value = value\n        }\n    }\n    reject(reason){\n        //失败后的一系列操作（状态的改变，失败回调的执行）\n        if(this.state === 'pending'){\n            //状态进行改变\n            this.state = Promise.REJECTED\n            //执行成功的回调，把据因进行赋值\n            this.reason = reason\n        }\n    }\n    then(onFulfilled, onRejected) {\n        //  参数效验\n        if (typeof onFulfilled !== 'function'){\n            onFulfilled = function(value) {\n                return value\n            }\n        }\n        if (typeof onRejected !== 'function'){\n            onRejected = function(reason){\n                throw reason\n            }\n        }\n        if(this.state === Promise.FULFILLED){\n            onFulfilled(this.value)\n        }\n        if(this.state === Promise.REJECTED){\n            onRejected(this.reason)\n        }\n    }\n}\nPromise.PENDING = 'pending'\nPromise.FULFILLED = 'fulfilled'\nPromise.REJECTED = 'reject'\n\nmodule.exports = Promise\n")])])]),s("p",[s("strong",[e._v("test.js")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const Promise = require('./promise.js')\n\nnew Promise((resolve, reject) => {\n    console.log('早上好！')\n        resolve(1)\n}).then(value=> {\n    console.log('value',value)\n},reason => {   \n    console.log('reason',value)\n})\n")])])]),s("p",[s("strong",[e._v("运行结果：")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("早上好！\nvalue 1\n")])])]),s("h1",{attrs:{id:"异步解决实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#异步解决实现"}},[e._v("#")]),e._v(" 异步解决实现")]),e._v(" "),s("h2",{attrs:{id:"先看一下这段代码的执行顺序是什么样的？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#先看一下这段代码的执行顺序是什么样的？"}},[e._v("#")]),e._v(" 先看一下这段代码的执行顺序是什么样的？")]),e._v(" "),s("blockquote",[s("p",[e._v("代码如下")])]),e._v(" "),s("p",[s("strong",[e._v("index.js")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("console.log('1')\nnew Promise((resolve, reject) => {\n    console.log('2')\n        resolve(1)\n    }).then(value => {\n    console.log('4')\n    console.log('value',value)\n},reason => {\n    console.log('reason',reason)\n})\nconsole.log('3')\n")])])]),s("p",[s("strong",[e._v("运行结果：")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("1\n2\n3\n4\nvalue 1\n")])])]),s("h2",{attrs:{id:"在测试文件运行这段代码执行顺序会是什么样？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#在测试文件运行这段代码执行顺序会是什么样？"}},[e._v("#")]),e._v(" 在测试文件运行这段代码执行顺序会是什么样？")]),e._v(" "),s("blockquote",[s("p",[e._v("代码如下")])]),e._v(" "),s("p",[s("strong",[e._v("test.js")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const Promise = require('./promise.js')\n\nconsole.log('1')\nnew Promise((resolve, reject) => {\n    console.log('2')\n        resolve(1)\n    }).then(value => {\n    console.log('4')//立即执行了\n    console.log('value',value)//立即执行了\n},reason => {\n    console.log('reason',reason)\n})\nconsole.log('3')\n")])])]),s("p",[s("strong",[e._v("运行结果：")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("1\n2\n4\nvalue 1\n3\n")])])]),s("h2",{attrs:{id:"如何来模拟异步呢？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何来模拟异步呢？"}},[e._v("#")]),e._v(" 如何来模拟异步呢？")]),e._v(" "),s("p",[e._v("在promise.js里面添加代码，利用setTimeout,再运行test.js")]),e._v(" "),s("blockquote",[s("p",[e._v("代码如下：")])]),e._v(" "),s("p",[s("strong",[e._v("promise.js")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("class Promise {\n    constructor(executor){\n        //不能相信用户的输入，所以这里要做参数效验\n        if(typeof executor !== 'function'){\n            throw new TypeError('Promise resolver ${executor} is not a function')\n        }\n\n        this.initValue()\n        this.initBind()\n\n        try{\n            executor(this.resolve, this.reject)\n        }catch(e){\n            this.reject(e)\n        }\n    }\n    //绑定 this\n    initBind(){\n        this.resolve = this.resolve.bind(this)\n        this.reject = this.reject.bind(this)\n    }\n    //进行代码的优化\n    initValue(){\n        //记录状态和值的改变\n        //初始化值\n        this.value = null //终值\n        this.reason = null //拒因\n        this.state = Promise.PENDING //状态\n    }\n    resolve(value){\n        //成功后的一系列操作（状态的改变，成功回调的执行）\n        if(this.state === Promise.PENDING){\n            //状态进行改变\n            this.state = Promise.FULFILLED\n            //执行成功的回调，把终值进行赋值\n            this.value = value\n        }\n    }\n    reject(reason){\n        //失败后的一系列操作（状态的改变，失败回调的执行）\n        if(this.state === 'pending'){\n            //状态进行改变\n            this.state = Promise.REJECTED\n            //执行成功的回调，把据因进行赋值\n            this.reason = reason\n        }\n    }\n    then(onFulfilled, onRejected) {\n        //  参数效验\n        if (typeof onFulfilled !== 'function'){\n            onFulfilled = function(value) {\n                return value\n            }\n        }\n        if (typeof onRejected !== 'function'){\n            onRejected = function(reason){\n                throw reason\n            }\n        }\n        if(this.state === Promise.FULFILLED){\n            setTimeout(() => {\n                onFulfilled(this.value)\n            })\n        }\n        if(this.state === Promise.REJECTED){\n            setTimeout(() => {\n                onRejected(this.reason)\n            })\n        }\n    }\n}\nPromise.PENDING = 'pending'\nPromise.FULFILLED = 'fulfilled'\nPromise.REJECTED = 'reject'\n\nmodule.exports = Promise\n")])])]),s("p",[s("strong",[e._v("test.js")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const Promise = require('./promise.js')\n\nconsole.log('1')\nnew Promise((resolve, reject) => {\n    console.log('2')\n        resolve(1)\n    }).then(value => {\n    console.log('4')\n    console.log('value',value)\n},reason => {\n    console.log('reason',reason)\n})\nconsole.log('3')\n")])])]),s("p",[s("strong",[e._v("运行结果：")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("1\n2\n3\n4\nvalue 1\n")])])]),s("h2",{attrs:{id:"假如在test-js里面抛出一个异常，会是怎么样？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#假如在test-js里面抛出一个异常，会是怎么样？"}},[e._v("#")]),e._v(" 假如在test.js里面抛出一个异常，会是怎么样？")]),e._v(" "),s("blockquote",[s("p",[e._v("代码如下：")])]),e._v(" "),s("p",[s("strong",[e._v("test.js")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const Promise = require('./promise.js')\n\nconsole.log('1')\nnew Promise((resolve, reject) => {\n    throw new Error('You write wrong')\n    // console.log('2')\n        resolve(1)\n    }).then(value => {\n    console.log('4')\n    console.log('value',value)\n},reason => {\n    console.log('reason',reason)\n})\nconsole.log('3')\n")])])]),s("p",[s("strong",[e._v("运行结果：")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("1\n3\nreason Error: You write wrong\n")])])]),s("p",[e._v("上边是直接在最外层进行一个抛出")]),e._v(" "),s("h2",{attrs:{id:"假设我们把代码放原生的promise里，会是怎样？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#假设我们把代码放原生的promise里，会是怎样？"}},[e._v("#")]),e._v(" 假设我们把代码放原生的promise里，会是怎样？")]),e._v(" "),s("blockquote",[s("p",[e._v("代码如下：")])]),e._v(" "),s("p",[s("strong",[e._v("index.js")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const Promise = require('./promise.js')\n\nconsole.log('1')\nnew Promise((resolve, reject) => {\n    throw new Error('You write wrong')\n    // console.log('2')\n        resolve(1)\n    }).then(value => {\n    console.log('4')\n    console.log('value',value)\n},reason => {\n    console.log('reason',reason)\n})\nconsole.log('3')\n")])])]),s("p",[s("strong",[e._v("运行结果：")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("1\n3\nreason Error: You write wrong\n")])])]),s("h2",{attrs:{id:"如果是test-js里是异步的会是什么样？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如果是test-js里是异步的会是什么样？"}},[e._v("#")]),e._v(" 如果是test.js里是异步的会是什么样？")]),e._v(" "),s("blockquote",[s("p",[e._v("代码如下：")])]),e._v(" "),s("p",[s("strong",[e._v("test.js")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const Promise = require('./promise.js')\n\nconsole.log('1')\nnew Promise((resolve, reject) => {\n        setTimeout(() => {\n            console.log('hello!')\n            resolve(1)\n        })\n    }).then(value => {\n    console.log('4')\n    console.log('value',value)\n},reason => {\n    console.log('reason',reason)\n})\nconsole.log('3')\n")])])]),s("p",[s("strong",[e._v("运行结果：")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("1\n3\nhello!\n")])])]),s("p",[s("strong",[e._v("不知道大家有没有发现 '4' 没有执行，这是什么原因呢？")])]),e._v(" "),s("p",[e._v("因为此时并没有直接进入setTimeout里面，而是进行了.then操作\n"),s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/1/18/16fb947d198dd677?w=384&h=394&f=png&s=31144",alt:"cmd-markdown-logo"}}),e._v("\n我们在promise.js里面看到，")]),e._v(" "),s("p",[e._v("此时.then操作的状态等于'pending',")]),e._v(" "),s("p",[e._v("它不等于'fulfilled',也不等于'reject',")]),e._v(" "),s("p",[e._v("所以它并没有执行这两个回调函数中的任意一个，所以.then方法并没有执行\n"),s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/1/18/16fb9486f497074e?w=624&h=508&f=png&s=45586",alt:"cmd-markdown-logo"}}),e._v(" "),s("strong",[e._v("怎么解决这个问题呢？")])]),e._v(" "),s("blockquote",[s("p",[e._v("首先在promise.js里面肯定要追加一个状态的判断")])]),e._v(" "),s("h2",{attrs:{id:"在promise-js里追加一个状态的判断"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#在promise-js里追加一个状态的判断"}},[e._v("#")]),e._v(" 在promise.js里追加一个状态的判断")]),e._v(" "),s("blockquote",[s("p",[e._v("代码如下：")])]),e._v(" "),s("p",[s("strong",[e._v("promise.js")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("class Promise {\n    constructor(executor){\n        //不能相信用户的输入，所以这里要做参数效验\n        if(typeof executor !== 'function'){\n            throw new TypeError('Promise resolver ${executor} is not a function')\n        }\n\n        this.initValue()\n        this.initBind()\n\n        try{\n            executor(this.resolve, this.reject)\n        }catch(e){\n            this.reject(e)\n        }\n    }\n    //绑定 this\n    initBind(){\n        this.resolve = this.resolve.bind(this)\n        this.reject = this.reject.bind(this)\n    }\n    //进行代码的优化\n    initValue(){\n        //记录状态和值的改变\n        //初始化值\n        this.value = null //终值\n        this.reason = null //拒因\n        this.state = Promise.PENDING //状态\n        this.onFulfilledCallbacks = []//成功回调\n        this.onRejectedCallbacks = [] //失败回调\n    }\n    resolve(value){\n        //成功后的一系列操作（状态的改变，成功回调的执行）\n        if(this.state === Promise.PENDING){\n            //状态进行改变\n            this.state = Promise.FULFILLED\n            //执行成功的回调，把终值进行赋值\n            this.value = value\n            //成功或者失败以后进行这两个数组的执行\n            this.onFulfilledCallbacks.forEach((fn) => fn(this.value)\n            )}\n    }\n    reject(reason){\n        //失败后的一系列操作（状态的改变，失败回调的执行）\n        if(this.state === 'pending'){\n            //状态进行改变\n            this.state = Promise.REJECTED\n            //执行成功的回调，把据因进行赋值\n            this.reason = reason\n            this.onRejectedCallbacks.forEach(fn => fn(this.reason))\n        }\n    }\n    then(onFulfilled, onRejected) {\n        //  参数效验\n        if (typeof onFulfilled !== 'function'){\n            onFulfilled = function(value) {\n                return value\n            }\n        }\n        if (typeof onRejected !== 'function'){\n            onRejected = function(reason){\n                throw reason\n            }\n        }\n        if(this.state === Promise.FULFILLED){\n            setTimeout(() => {\n                onFulfilled(this.value)\n            })\n        }\n        if(this.state === Promise.REJECTED){\n            setTimeout(() => {\n                onRejected(this.reason)\n            })\n        }\n        //在promise.js里面肯定要追加一个状态的判断\n        if(this.state === Promise.PENDING){\n            this.onFulfilledCallbacks.push((value) => {\n                setTimeout(() => {\n                    onFulfilled(value)\n                })\n            })\n            this.onRejectedCallbacks.push((reason) => {\n                setTimeout(() => {\n                    onRejected(this.reason)\n                })\n            })\n        }\n    }\n}\nPromise.PENDING = 'pending'\nPromise.FULFILLED = 'fulfilled'\nPromise.REJECTED = 'reject'\n\nmodule.exports = Promise\n")])])]),s("p",[s("strong",[e._v("运行结果：")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("1\n3\nhello!\n4\nvalue 1\n")])])]),s("h1",{attrs:{id:"链式调用的简单解决方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#链式调用的简单解决方案"}},[e._v("#")]),e._v(" 链式调用的简单解决方案")]),e._v(" "),s("h2",{attrs:{id:"如何实现链式调用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何实现链式调用"}},[e._v("#")]),e._v(" 如何实现链式调用")]),e._v(" "),s("blockquote",[s("p",[e._v("代码如下：")])]),e._v(" "),s("p",[s("strong",[e._v("index.js")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("new Promise((resolve, reject) => {\n        resolve(1)\n    })\n    .then(\n        value => {\n         return 'good' + value\n    },\n    reason => {\n        console.log('reason',reason)\n    }\n    )\n    .then(\n        value => {\n        console.log('value',value)\n    },\n    reason => {\n        console.log('reason',reason)\n}\n)\n")])])]),s("p",[s("strong",[e._v("运行结果：")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("value good1\n")])])]),s("h2",{attrs:{id:"如何才能做到链式调用呢？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何才能做到链式调用呢？"}},[e._v("#")]),e._v(" 如何才能做到链式调用呢？")]),e._v(" "),s("p",[e._v("实现链式调用，且改变了后面的then的值，必须通过新的实例")]),e._v(" "),s("blockquote",[s("p",[e._v("代码如下：")])]),e._v(" "),s("p",[s("strong",[e._v("index.js")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("new Promise((resolve, reject) => {\n    // throw new Error('You write wrong')\n    // console.log('2')\n        resolve(1)\n    })\n    .then(\n        value => {\n         throw new Error('use')\n         return 'good' + value\n    },\n    reason => {\n        console.log('reason',reason)\n    }\n    )\n    .then(\n        value => {\n        console.log('value',value)\n    },\n    reason => {\n        console.log('reason',reason)\n}\n)\n")])])]),s("p",[s("strong",[e._v("promise.js")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("class Promise {\n    constructor(executor){\n        //不能相信用户的输入，所以这里要做参数效验\n        if(typeof executor !== 'function'){\n            throw new TypeError('Promise resolver ${executor} is not a function')\n        }\n\n        this.initValue()\n        this.initBind()\n\n        try{\n            executor(this.resolve, this.reject)\n        }catch(e){\n            this.reject(e)\n        }\n    }\n    //绑定 this\n    initBind(){\n        this.resolve = this.resolve.bind(this)\n        this.reject = this.reject.bind(this)\n    }\n    //进行代码的优化\n    initValue(){\n        //记录状态和值的改变\n        //初始化值\n        this.value = null //终值\n        this.reason = null //拒因\n        this.state = Promise.PENDING //状态\n        this.onFulfilledCallbacks = []//成功回调\n        this.onRejectedCallbacks = [] //失败回调\n    }\n    resolve(value){\n        //成功后的一系列操作（状态的改变，成功回调的执行）\n        if(this.state === Promise.PENDING){\n            //状态进行改变\n            this.state = Promise.FULFILLED\n            //执行成功的回调，把终值进行赋值\n            this.value = value\n            //成功或者失败以后进行这两个数组的执行\n            this.onFulfilledCallbacks.forEach((fn) => fn(this.value)\n            )}\n    }\n    reject(reason){\n        //失败后的一系列操作（状态的改变，失败回调的执行）\n        if(this.state === 'pending'){\n            //状态进行改变\n            this.state = Promise.REJECTED\n            //执行成功的回调，把据因进行赋值\n            this.reason = reason\n            this.onRejectedCallbacks.forEach(fn => fn(this.reason))\n        }\n    }\n    then(onFulfilled, onRejected) {\n        //  参数效验\n        if (typeof onFulfilled !== 'function'){\n            onFulfilled = function(value) {\n                return value\n            }\n        }\n        if (typeof onRejected !== 'function'){\n            onRejected = function(reason){\n                throw reason\n            }\n        }\n        // 实现链式调用，且改变了后面的then的值，必须通过新的实例\n        let promise2 = new Promise((resolve, reject) => {\n            if(this.state === Promise.FULFILLED){\n                setTimeout(() => {\n                    try{\n                        const x = onFulfilled(this.value)\n                        resolve(x)\n                    }catch(e){\n                        reject(e)\n                    }\n                })\n            }\n            if(this.state === Promise.REJECTED){\n                setTimeout(() => {\n                    try{\n                        const x = onRejected(this.reason)\n                        resolve(x)\n                    }catch(e){\n                        reject(e)\n                    }\n                })\n            }\n            //在promise.js里面肯定要追加一个状态的判断\n            if(this.state === Promise.PENDING){\n                this.onFulfilledCallbacks.push((value) => {\n                    setTimeout(() => {\n                        try{\n                            const x = onFulfilled(value)\n                            resolve(x)\n                        }catch(e){\n                            reject(e)\n                        }\n                    })\n                })\n                this.onRejectedCallbacks.push((reason) => {\n                    setTimeout(() => {\n                        try{\n                            const x = onRejected(this.reason)\n                            resolve(x)\n                        }catch(e){\n                            reject(e)\n                        }\n                    })\n                })\n            }\n        })\n        return promise2\n    }\n}\nPromise.PENDING = 'pending'\nPromise.FULFILLED = 'fulfilled'\nPromise.REJECTED = 'reject'\nPromise.resolvePromise = function(promise2, x, resolve, reject){}\n\nmodule.exports = Promise\n")])])]),s("p",[s("strong",[e._v("运行结果：")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("reason Error: use\n")])])]),s("h1",{attrs:{id:"链式调用的终极解决方案和测试"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#链式调用的终极解决方案和测试"}},[e._v("#")]),e._v(" 链式调用的终极解决方案和测试")]),e._v(" "),s("h2",{attrs:{id:"当返回值不是一个普通数值或一个基本类型，会是什么样情况？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#当返回值不是一个普通数值或一个基本类型，会是什么样情况？"}},[e._v("#")]),e._v(" 当返回值不是一个普通数值或一个基本类型，会是什么样情况？")]),e._v(" "),s("blockquote",[s("p",[e._v("代码如下：")])]),e._v(" "),s("p",[s("strong",[e._v("test.js")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const Promise = require('./promise.js')\n\nnew Promise((resolve, reject) => {\n    // throw new Error('You write wrong')\n    // console.log('2')\n        resolve(1)\n    })\n    .then(\n        value => {\n         return new Promise((resolve) => {\n             resolve(1)\n         })\n    },\n    reason => {\n        console.log('reason',reason)\n    }\n    )\n    .then(\n        value => {\n        console.log('value',value)\n    },\n    reason => {\n        console.log('reason',reason)\n}\n)\n")])])]),s("p",[s("strong",[e._v("运行结果：")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("value Promise {\n  value: 1,\n  reason: null,\n  state: 'fulfilled',\n  onFulfilledCallbacks: [],\n  onRejectedCallbacks: [],\n  resolve: [Function: bound resolve],\n  reject: [Function: bound reject] }\n")])])]),s("p",[s("strong",[e._v("分析结果可知：")])]),e._v(" "),s("p",[e._v("当x的值不是基本值的时候，而是promise实例得时候，必须等待这一个promise的时候结束，才能进行进一步执行\n"),s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/1/19/16fbbeeff141ee0f?w=602&h=327&f=png&s=26170",alt:"cmd-markdown-logo"}}),e._v("\n所以规范提出了一个解决方案\n针对resolvePromise的具体解决过程\n"),s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/1/19/16fbbf120bafe8d7?w=668&h=280&f=png&s=28283",alt:"cmd-markdown-logo"}}),e._v("\n首先是判断promise2和x的值是否是相等的")]),e._v(" "),s("p",[e._v("如果相等的话，就抛出一个TypeError,是为了避免循环调用的问题")]),e._v(" "),s("p",[e._v("我们可以通过代码看一下：")]),e._v(" "),s("p",[s("strong",[e._v("index.js")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("let p1 = new Promise((resolve) => {\n    resolve(1)\n})\nlet p2 = p1.then(() => {\n    return p2\n})\n")])])]),s("p",[s("strong",[e._v("运行结果：")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("TypeError: Chaining cycle detected for promise\n")])])]),s("p",[e._v("链式调用出现了问题")]),e._v(" "),s("h2",{attrs:{id:"在promise-js里面处理一下"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#在promise-js里面处理一下"}},[e._v("#")]),e._v(" 在promise.js里面处理一下")]),e._v(" "),s("p",[s("strong",[e._v("promise.js")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("class Promise {\n    constructor(executor) {\n      // 参数校检\n      if (typeof executor !== 'function') {\n        throw new TypeError(`Promise resolver ${executor} is not a function`)\n      }\n  \n      this.initValue()\n      this.initBind()\n  \n      try {\n        executor(this.resolve, this.reject)\n      } catch (e) {\n        this.reject(e)\n      }\n    }\n  \n    // 绑定 this\n    initBind() {\n      this.resolve = this.resolve.bind(this)\n      this.reject = this.reject.bind(this)\n    }\n  \n    // 初始化值\n    initValue() {\n      this.value = null // 终值\n      this.reason = null // 拒因\n      this.state = Promise.PENDING // 状态\n      this.onFulfilledCallbacks = [] // 成功回调\n      this.onRejectedCallbacks = [] // 失败回调\n    }\n  \n    resolve(value) {\n      // 成功后的一系列操作(状态的改变, 成功回调的执行)\n      if (this.state === Promise.PENDING) {\n        this.state = Promise.FULFILLED\n        this.value = value\n        this.onFulfilledCallbacks.forEach(fn => fn(this.value))\n      }\n    }\n  \n    reject(reason) {\n      // 失败后的一系列操作(状态的改变, 失败回调的执行)\n      if (this.state === 'pending') {\n        this.state = Promise.REJECTED\n        this.reason = reason\n        this.onRejectedCallbacks.forEach(fn => fn(this.reason))\n      }\n    }\n  \n    then(onFulfilled, onRejected) {\n      // 参数校检\n      if (typeof onFulfilled !== 'function') {\n        onFulfilled = function(value) {\n          return value\n        }\n      }\n  \n      if (typeof onRejected !== 'function') {\n        onRejected = function(reason) {\n          throw reason\n        }\n      }\n  \n      // 实现链式调用, 且改变了后面then的值, 必须通过新的实例\n      let promise2 = new Promise((resolve, reject) => {\n        if (this.state === Promise.FULFILLED) {\n          setTimeout(() => {\n            try {\n              const x = onFulfilled(this.value)\n              Promise.resolvePromise(promise2, x, resolve, reject)\n            } catch (e) {\n              reject(e)\n            }\n          })\n        }\n  \n        if (this.state === Promise.REJECTED) {\n          setTimeout(() => {\n            try {\n              const x = onRejected(this.reason)\n              Promise.resolvePromise(promise2, x, resolve, reject)\n            } catch (e) {\n              reject(e)\n            }\n          })\n        }\n  \n        if (this.state === Promise.PENDING) {\n          this.onFulfilledCallbacks.push(value => {\n            setTimeout(() => {\n              try {\n                const x = onFulfilled(value)\n                Promise.resolvePromise(promise2, x, resolve, reject)\n              } catch (e) {\n                reject(e)\n              }\n            })\n          })\n  \n          this.onRejectedCallbacks.push(reason => {\n            setTimeout(() => {\n              try {\n                const x = onRejected(this.reason)\n                Promise.resolvePromise(promise2, x, resolve, reject)\n              } catch (e) {\n                reject(e)\n              }\n            })\n          })\n        }\n      })\n  \n      return promise2\n    }\n  }\n  \n  Promise.PENDING = 'pending'\n  Promise.FULFILLED = 'fulfilled'\n  Promise.REJECTED = 'reject'\n  Promise.resolvePromise = function(promise2, x, resolve, reject) {\n    // x 与 promise 相等\n    if (promise2 === x) {\n      reject(new TypeError('Chaining cycle detected for promise'))\n    }\n  \n    let called = false\n    if (x instanceof Promise) {\n      // 判断 x 为 Promise\n      x.then(\n        value => {\n          Promise.resolvePromise(promise2, value, resolve, reject)\n        },\n        reason => {\n          reject(reason)\n        }\n      )\n    } else if (x !== null && (typeof x === 'object' || typeof x === 'function')) {\n      // x 为对象或函数\n      try {\n        const then = x.then\n        if (typeof then === 'function') {\n          then.call(\n            x,\n            value => {\n              if (called) return\n              called = true\n              Promise.resolvePromise(promise2, value, resolve, reject)\n            },\n            reason => {\n              if (called) return\n              called = true\n              reject(reason)\n            }\n          )\n        } else {\n          if (called) return\n          called = true\n          resolve(x)\n        }\n      } catch (e) {\n        if (called) return\n        called = true\n        reject(e)\n      }\n    } else {\n      resolve(x)\n    }\n  }\n  \n  module.exports = Promise\n")])])]),s("p",[s("strong",[e._v("test.js")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const Promise = require('./promise.js')\n\nnew Promise((resolve, reject) => {\n    // throw new Error('You write wrong')\n    // console.log('2')\n        resolve(1)\n    })\n    .then(\n        value => {\n         return new Promise((resolve) => {\n             resolve(new Promise((resolve,reject) => {\n                 resolve('333')\n             })\n             )\n         })\n    },\n    reason => {\n        console.log('reason',reason)\n    }\n    )\n    .then(\n        value => {\n        console.log('then 2 value:',value)\n    },\n    reason => {\n        console.log('reason',reason)\n}\n)\n")])])]),s("p",[s("strong",[e._v("运行结果：")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("then 2 value: 333\n")])])]),s("h1",{attrs:{id:"如何验证我们的promise是否正确"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何验证我们的promise是否正确"}},[e._v("#")]),e._v(" 如何验证我们的promise是否正确")]),e._v(" "),s("h2",{attrs:{id:"首先"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#首先"}},[e._v("#")]),e._v(" 首先")]),e._v(" "),s("p",[e._v("我们需要安装一个promises-aplus-tests")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("npm install promises-aplus-tests\n")])])]),s("p",[e._v("用来测试自己的promise 符不符合promisesA+规范")]),e._v(" "),s("h2",{attrs:{id:"然后"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#然后"}},[e._v("#")]),e._v(" 然后")]),e._v(" "),s("p",[e._v("把下边这段代码copy到promise.js里面")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("Promise.defer = Promise.deferred = function () {\n  let dfd = {}\n  dfd.promise = new Promise((resolve,reject)=>{\n    dfd.resolve = resolve;\n    dfd.reject = reject;\n  });\n  return dfd;\n}\nmodule.exports = Promise;\n")])])]),s("h2",{attrs:{id:"最后"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#最后"}},[e._v("#")]),e._v(" 最后")]),e._v(" "),s("p",[e._v("执行输入npx promises-aplus-tests 你要测试的文件(promise.js)")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("npx promises-aplus-tests promise.js\n")])])]),s("p",[s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/1/19/16fbc120a5289ece?w=632&h=50&f=png&s=5680",alt:"cmd-markdown-logo"}}),e._v("\n以上，我们就完成了一个基于Promise A+规范的Promise")]),e._v(" "),s("h1",{attrs:{id:"最后扩展"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#最后扩展"}},[e._v("#")]),e._v(" 最后扩展")]),e._v(" "),s("h2",{attrs:{id:"源码地址"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#源码地址"}},[e._v("#")]),e._v(" 源码地址")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("https://github.com/shifengming/promise\n")])])])])}),[],!1,null,null,null);n.default=r.exports}}]);