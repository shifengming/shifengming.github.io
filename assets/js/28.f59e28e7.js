(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{237:function(t,s,a){"use strict";a.r(s);var n=a(0),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[t._v("#")]),t._v(" 继承")]),t._v(" "),a("h2",{attrs:{id:"概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[t._v("#")]),t._v(" 概念")]),t._v(" "),a("p",[t._v("封装：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("低耦合高内聚\n")])])]),a("p",[t._v("多态：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("重载和重写\n")])])]),a("p",[t._v("重载：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("方法名相同，形参个数或者类型不一样\n(JS中不存在真正意义上的重载，JS中重载指的是同一个方法，根据传参不同，实现出不同的效果)\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function sum(x,y,z){\n\tif(typeof z==='undefined'){\n\t\treturn;\n\t}\n}\nsum(1,2)\nsum(1,2,3)\n")])])]),a("p",[t._v("重写：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("在类的继承中，子类可以重写父类中的方法\n")])])]),a("h2",{attrs:{id:"面向对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面向对象"}},[t._v("#")]),t._v(" 面向对象")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("面向对象是一种编程思想，js本身就是基于面向对象构建出来的\n(例如：JS中有很多内置类，像Promise就是ES6中新增的一个内置类，我们可以基于new Promise来创建一个实例，来管理异步编程，我在项目中，Promise也经常用，自己也研究过它的源码....)我之前看过一点框架源码\n我们平时用的VUE/REACT/JQUERY也是基于面向对象构建出来的，他们都是类，平时开发的时候都是创建的他们的实例来操作的：当然我自己在真实的项目中，也封装过一些组件插件(例如：DIALOG、拖拽、...)也是基于面向对象开发的，这样可以创在不同的实例，来管理私有的属性和共有的方法，很方便...\nJS中面向对象，和其它编程语言还是有略微不同，JS中类和实例是基于原型和原型链机制来处理的，而且JS中关于类的多态重载、重写、继承也和其它语言不太一样...\n")])])]),a("h2",{attrs:{id:"继承-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#继承-2"}},[t._v("#")]),t._v(" 继承")]),t._v(" "),a("p",[t._v("继承：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("子类继承父类中的属性和方法(目的是让子类的实例能够调取父类中的属性和方法)\n")])])]),a("p",[t._v("方法一：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("\t原型继承，让父类中的属性和方法在子类实例的原型链上，\n       CHILD.prototype=new PARENT()\n       CHILD.prototype.constructor = CHILD;\n")])])]),a("p",[t._v("特点：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1，不像其他语言中的继承一样（其它语言的继承一般是拷贝继承，也就是子类继承父类，会把父类中的属性和方法拷贝一份到子类中，供子类的实例调取使用），它是吧父类的原型放到子类实例的原型链上，实例想调用这些方法，是基于_proto_原型链查找机制完成的\n2，子类可以重写父类上得方法（这样会导致父类其它得实例也受到影响）\n3，父类中私有或者公有得属性方法，最后都会变成子类中公有得属性和方法\n")])])]),a("p",[t._v("使用：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function A(x){\n            this.x=x;\n        }\n        A.prototype.getX = function (){\n            console.log(this.x)\n        }\n        function B(y){\n            this.y = y;\n        }\n        B.prototype = new A(200);\n        B.prototype.constructor = B;\n        B.prototype.getY=function(){\n            console.log(this.y)\n        };\n        let b1 = new B(100);\n        b1.y;\n        b1.getY();\n        b1.getX();\n")])])]),a("h2",{attrs:{id:"call继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#call继承"}},[t._v("#")]),t._v(" CALL继承")]),t._v(" "),a("p",[t._v("特点：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("CHILD方法中把PARENT当作普通函数执行，让PARENT中的THIS指向CHILD的实例，相当于给CHILD的实例设置了很大私有的属性或者方法\n1，只能继承父类私有的属性或者方法（因为是把PARENT当作普通函数执行，和其原型上的属性和方法没有关系）\n2，父类私有的变成子类私有的\n")])])]),a("p",[t._v("使用：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("        function A(x){\n            this.x=x;\n        }\n        A.prototype.getX = function (){\n            console.log(this.x)\n        }\n        function B(y){\n        \tA.call(this,200);\n            this.y = y;\n        }\n        B.prototype=Object.create(A.prototype);\n        B.prototype.constructor = B;\n        B.prototype.getY=function(){\n            console.log(this.y)\n        };\n        let b1 = new B(100);\n")])])]),a("h2",{attrs:{id:"寄生组合继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#寄生组合继承"}},[t._v("#")]),t._v(" 寄生组合继承")]),t._v(" "),a("p",[t._v("特点：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("父类私有和公有的分别是子类实例的私有和公有属性方法(推荐)\n")])])]),a("p",[t._v("使用：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Object.create = function (obj){\n\tfunction Fn() {}\n\tFn.prototype = obj;\n\treturn new Fn();\n}\n")])])]),a("h2",{attrs:{id:"es6中的继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#es6中的继承"}},[t._v("#")]),t._v(" es6中的继承")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("class B extends A{\n\tconstrucor(y){\n\t //子类只要继承父类，可以不写CONSTRUCTOR,一旦泄露，则在CONSTRUCTOR中的第一句话必须是SUPER()\n\t super(200);\n\t //A.call(this,200)把父类当作普通方法执行，给方法传递参数，让方法中的THIS是子类的实例\n\t //不写CONSTRUCTOR,浏览器会自己默认创建CONSTRUCTOR(...args){super(...args)}\n\t this.y=y;\n\t}\n\tgetY(){\n\t\tconsole.log(this.y)\n\t}\n}\nlet b1=new B(100);\nconsole.log(b1);\n")])])]),a("p",[t._v("使用")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("//第一种\nclass Login extends React.Components{\n\tconstructor(props){\n\t super(props);\n\t}\n\tcomponentWillMount(){\n\t  this.setState();\n\t}\n\trender(){\n\t\n\t}\n\tcomponentDidMount(){\n\t\n\t}\n}\n//第二种\n//Promise.prototype:then catch finally...\nclass Dialog extends Promise{\n\tconstructor(){\n\t\tsuper();\n\t}\n\tshow(){\n\t \tthis.then().then();\n\t}\n}\n//第三种\nclass Utils{\n  query(){\n\t}\n}\nclass Dialog extends Utils{\n\tconstructor(){\n\t super();\n\t}\n}\n")])])])])}),[],!1,null,null,null);s.default=e.exports}}]);