(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{214:function(t,a,e){"use strict";e.r(a);var s=e(0),v=Object(s.a)({},(function(){this._self._c;return this._m(0)}),[function(){var t=this,a=t._self._c;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"重点题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重点题"}},[t._v("#")]),t._v(" 重点题")]),t._v(" "),a("h2",{attrs:{id:"js的几条基本规范"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js的几条基本规范"}},[t._v("#")]),t._v(" JS的几条基本规范")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1、不要在同一行声明多个变量\n2、请使用===/！==来比较true/false或者数值\n3、使用对象字面量替代new Array这种形式\n4、不要使用全局变量\n5、Switch语句必须带有default分支\n6、函数不应该有时候有返回值，有时候没有返回值\n7、For循环必须使用大括号\n8、IF语句必须使用大括号\n9、for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染\n\n")])])]),a("h2",{attrs:{id:"js引用方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js引用方法"}},[t._v("#")]),t._v(" JS引用方法")]),t._v(" "),a("p",[t._v("行内引入")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<body>\n  <input type="button" onclick="alert(\'行内引入\')" value="按钮"/>\n  <button onclick="alert(123)">点击我</button>\n</body>\n')])])]),a("p",[t._v("内部引入")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<script>\n  window.onload = function() {\n    alert("js 内部引入！");\n  }\n<\/script>\n')])])]),a("p",[t._v("外部引入")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<body>\n  <div></div>\n\n  <script type="text/javascript" src="./js/index.js"><\/script>\n</body>\n')])])]),a("p",[t._v("注意")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1，不推荐写行内或者HTML中插入<script>,因为浏览器解析顺序缘故，如果解析到死循环之类的JS代码，会卡住页面\n2，建议在onload事件之后，即等HTML、CSS渲染完毕再执行代码\n")])])]),a("h2",{attrs:{id:"js的基本数据类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js的基本数据类型"}},[t._v("#")]),t._v(" JS的基本数据类型")]),t._v(" "),a("p",[t._v("Undefined、Null、Boolean、Number、String、新增:Symbol")]),t._v(" "),a("h2",{attrs:{id:"数组操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数组操作"}},[t._v("#")]),t._v(" 数组操作")]),t._v(" "),a("blockquote",[a("p",[t._v("在 JavaScript 中，用得较多的之一无疑是数组操作，这里过一遍数组的一些用法")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("map: 遍历数组，返回回调返回值组成的新数组\nforEach: 无法break，可以用try/catch中throw new Error来停止\nfilter: 过滤\nsome: 有一项返回true，则整体为true\nevery: 有一项返回false，则整体为false\njoin: 通过指定连接符生成字符串\npush / pop: 末尾推入和弹出，改变原数组， 返回推入/弹出项【有误】\nunshift / shift: 头部推入和弹出，改变原数组，返回操作项【有误】\nsort(fn) / reverse: 排序与反转，改变原数组\nconcat: 连接数组，不影响原数组， 浅拷贝\nslice(start, end): 返回截断后的新数组，不改变原数组\nsplice(start, number, value...): 返回删除元素组成的数组，value 为插入项，改变原数组\nindexOf / lastIndexOf(value, fromIndex): 查找数组项，返回对应的下标\nreduce / reduceRight(fn(prev, cur)， defaultPrev): 两两执行，prev 为上次化简函数的return值，cur 为当前值(从第二项开始)\n")])])]),a("h2",{attrs:{id:"js有哪些内置对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js有哪些内置对象"}},[t._v("#")]),t._v(" JS有哪些内置对象")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Object是JavaScript中所有对象的父对象\n\n数据封装对象：Object、Array、Boolean、Number和String\n其他对象：Function、Arguments、Math、Date、RegExp、Error\n")])])]),a("h2",{attrs:{id:"get请求传参长度的误区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get请求传参长度的误区"}},[t._v("#")]),t._v(" get请求传参长度的误区")]),t._v(" "),a("p",[t._v("误区：我们经常说get请求参数的大小存在限制，而post请求的参数大小是无限制的")]),t._v(" "),a("p",[t._v("实际上HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对get请求参数的限制是来源与浏览器或web服务器，浏览器或web服务器限制了url的长度。为了明确这个概念，我们必须再次强调下面几点:")]),t._v(" "),a("p",[t._v("1、HTTP 协议 未规定 GET 和POST的长度限制")]),t._v(" "),a("p",[t._v("2、GET的最大长度显示是因为 浏览器和 web服务器限制了 URI的长度")]),t._v(" "),a("p",[t._v("3、不同的浏览器和WEB服务器，限制的最大长度不一样")]),t._v(" "),a("p",[t._v("4、要支持IE，则最大长度为2083byte，若只支持Chrome，则最大长度 8182byte")]),t._v(" "),a("h2",{attrs:{id:"补充get和post请求在缓存方面的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#补充get和post请求在缓存方面的区别"}},[t._v("#")]),t._v(" 补充get和post请求在缓存方面的区别")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。")])]),t._v(" "),a("li",[a("p",[t._v("post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。")])])]),t._v(" "),a("h2",{attrs:{id:"闭包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[t._v("#")]),t._v(" 闭包")]),t._v(" "),a("p",[t._v("什么是闭包？")]),t._v(" "),a("p",[t._v("函数A 里面包含了 函数B，而 函数B 里面使用了 函数A 的变量，那么 函数B 被称为闭包。")]),t._v(" "),a("p",[t._v("又或者：闭包就是能够读取其他函数内部变量的函数")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function A() {\n  var a = 1;\n  function B() {\n    console.log(a);\n  }\n  return B();\n}\n")])])]),a("p",[t._v("闭包的特征")]),t._v(" "),a("ul",[a("li",[t._v("函数内再嵌套函数")]),t._v(" "),a("li",[t._v("内部函数可以引用外层的参数和变量")]),t._v(" "),a("li",[t._v("参数和变量不会被垃圾回收制回收")])]),t._v(" "),a("p",[t._v("对闭包的理解：")]),t._v(" "),a("p",[t._v("使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念")]),t._v(" "),a("p",[t._v("闭包 的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中")]),t._v(" "),a("p",[t._v("闭包的另一个用处，是封装对象的私有属性和私有方法")]),t._v(" "),a("p",[t._v("闭包的好处：")]),t._v(" "),a("p",[t._v("能够实现封装和缓存等")]),t._v(" "),a("p",[t._v("闭包的坏处：")]),t._v(" "),a("p",[t._v("就是消耗内存、不正当使用会造成内存溢出的问题")]),t._v(" "),a("p",[t._v("使用闭包的注意点：")]),t._v(" "),a("p",[t._v("由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露")]),t._v(" "),a("p",[t._v("解决方法是：在退出函数之前，将不使用的局部变量全部删除")]),t._v(" "),a("p",[t._v("闭包的经典问题")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("for(var i = 0; i < 3; i++) {\n  setTimeout(function() {\n    console.log(i);\n  }, 1000);\n}\n")])])]),a("p",[t._v("这段代码输出")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("答案：3个3\n解析：首先，for 循环是同步代码，先执行三遍 for，i 变成了 3；然后，再执行异步代码 setTimeout，这时候输出的 i，只能是 3 个 3 了\n")])])]),a("p",[t._v("有什么办法依次输出0 1 2")]),t._v(" "),a("blockquote",[a("p",[t._v("第一种方法")])]),t._v(" "),a("p",[t._v("使用let")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("for(let i = 0; i < 3; i++) {\n  setTimeout(function() {\n    console.log(i);\n  }, 1000);\n}\n")])])]),a("p",[t._v("在这里，每个 let 和代码块结合起来形成块级作用域，当 setTimeout() 打印时，会寻找最近的块级作用域中的 i，所以依次打印出 0 1 2")]),t._v(" "),a("p",[t._v("如果这样不明白，我们可以执行下边这段代码")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('for(let i = 0; i < 3; i++) {\n  console.log("定时器外部：" + i);\n  setTimeout(function() {\n    console.log(i);\n  }, 1000);\n}\n')])])]),a("p",[t._v("此时浏览器依次输出的是：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("定时器外部：0\n定时器外部：1\n定时器外部：2\n0\n1\n2\n")])])]),a("p",[t._v("即代码还是先执行 for 循环，但是当 for 结束执行到了 setTimeout 的时候，它会做个标记，这样到了 console.log(i) 中，i 就能找到这个块中最近的变量定义")]),t._v(" "),a("blockquote",[a("p",[t._v("第二种方法")])]),t._v(" "),a("p",[t._v("使用立即执行函数解决闭包的问题")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("for(let i = 0; i < 3; i++) {\n  (function(i){\n    setTimeout(function() {\n      console.log(i);\n    }, 1000);\n  })(i)\n}\n")])])]),a("h2",{attrs:{id:"js作用域及作用域链"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js作用域及作用域链"}},[t._v("#")]),t._v(" JS作用域及作用域链")]),t._v(" "),a("p",[t._v("作用域：")]),t._v(" "),a("p",[t._v("在JavaScript中，作用域分为 全局作用域 和 函数作用域")]),t._v(" "),a("blockquote",[a("p",[t._v("全局作用域")])]),t._v(" "),a("p",[t._v("代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域")]),t._v(" "),a("blockquote",[a("p",[t._v("函数作用域")])]),t._v(" "),a("p",[t._v("在固定的代码片段才能被访问")]),t._v(" "),a("p",[t._v("例子：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/16/16d382c7d68e17ae~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp",alt:"cmd-markdown-logo"}})]),t._v(" "),a("p",[t._v("作用域有上下级关系，上下级关系的确定就看函数是在哪个作用域下创建的。如上，fn作用域下创建了bar函数，那么“fn作用域”就是“bar作用域”的上级。")]),t._v(" "),a("p",[t._v("作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。")]),t._v(" "),a("p",[t._v("变量取值：到创建 这个变量 的函数的作用域中取值")]),t._v(" "),a("p",[t._v("作用域链：")]),t._v(" "),a("p",[t._v("一般情况下，变量取值到 创建 这个变量 的函数的作用域中取值。")]),t._v(" "),a("p",[t._v("但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/16/16d3830bf3cf1ebf~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp",alt:"cmd-markdown-logo"}})]),t._v(" "),a("h2",{attrs:{id:"原型和原型链"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原型和原型链"}},[t._v("#")]),t._v(" 原型和原型链")]),t._v(" "),a("p",[t._v("原型和原型链的概念：")]),t._v(" "),a("p",[t._v("每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去")]),t._v(" "),a("p",[t._v("原型和原型链的关系：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("instance.constructor.prototype = instance.__proto__\n")])])]),a("p",[t._v("原型和原型链的特点：")]),t._v(" "),a("p",[t._v("JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变")]),t._v(" "),a("p",[t._v("当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的")]),t._v(" "),a("p",[t._v("就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象")]),t._v(" "),a("h2",{attrs:{id:"组件化和模块化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件化和模块化"}},[t._v("#")]),t._v(" 组件化和模块化")]),t._v(" "),a("p",[a("strong",[t._v("组件化")])]),t._v(" "),a("p",[t._v("为什么要组件化开发：")]),t._v(" "),a("p",[t._v("有时候页面代码量太大，逻辑太多或者同一个功能组件在许多页面均有使用，维护起来相当复杂，这个时候，就需要组件化开发来进行功能拆分、组件封装，已达到组件通用性，增强代码可读性，维护成本也能大大降低")]),t._v(" "),a("p",[t._v("组件化开发的优点：")]),t._v(" "),a("p",[t._v("很大程度上降低系统各个功能的耦合性，并且提高了功能内部的聚合性。这对前端工程化及降低代码的维护来说，是有很大的好处的，耦合性的降低，提高了系统的伸展性，降低了开发的复杂度，提升开发效率，降低开发成本")]),t._v(" "),a("p",[t._v("组件化开发的原则：")]),t._v(" "),a("p",[t._v("专一")]),t._v(" "),a("p",[t._v("可配置性")]),t._v(" "),a("p",[t._v("标准性")]),t._v(" "),a("p",[t._v("复用性")]),t._v(" "),a("p",[t._v("可维护性")]),t._v(" "),a("p",[a("strong",[t._v("模块化")])]),t._v(" "),a("p",[t._v("为什么要模块化？")]),t._v(" "),a("p",[t._v("早期的javascript版本没有块级作用域、没有类、没有包、也没有模块，这样会带来一些问题，如复用、依赖、冲突、代码组织混乱等，随着前端的膨胀，模块化显得非常迫切")]),t._v(" "),a("p",[t._v("模块化的好处：")]),t._v(" "),a("p",[t._v("避免变量污染，命名冲突")]),t._v(" "),a("p",[t._v("提高代码复用率")]),t._v(" "),a("p",[t._v("提高了可维护性")]),t._v(" "),a("p",[t._v("方便依赖关系管理")]),t._v(" "),a("p",[t._v("模块化的几种方法：")]),t._v(" "),a("ul",[a("li",[t._v("函数封装")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var myModule = {\n    var1: 1,\n    \n    var2: 2,\n    \n    fn1: function(){\n    \n    },\n    \n    fn2: function(){\n    \n    }\n}\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("总结：这样避免了变量污染，只要保证模块名唯一即可，同时同一模块内的成员也有了关系\n\n缺陷：外部可以睡意修改内部成员，这样就会产生意外的安全问题\n")])])]),a("ul",[a("li",[t._v("立即执行函数表达式(IIFE)")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var myModule = (function(){\n    var var1 = 1;\n    var var2 = 2;\n    \n    function fn1(){\n    \n    } \n    \n    function fn2(){\n    \n    }\n\nreturn {\n    fn1: fn1,\n    fn2: fn2\n};\n})();\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("总结：这样在模块外部无法修改我们没有暴露出来的变量、函数\n\n缺点：功能相对较弱，封装过程增加了工作量，仍会导致命名空间污染可能、闭包是有成本的\n")])])]),a("h2",{attrs:{id:"图片的预加载和懒加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#图片的预加载和懒加载"}},[t._v("#")]),t._v(" 图片的预加载和懒加载")]),t._v(" "),a("ul",[a("li",[t._v("预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染")]),t._v(" "),a("li",[t._v("懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数")])]),t._v(" "),a("p",[t._v("两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。预加载则会增加服务器前端压力，懒加载对服务器有一定的缓解压力作用。")]),t._v(" "),a("h2",{attrs:{id:"mouseover和mouseenter的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mouseover和mouseenter的区别"}},[t._v("#")]),t._v(" mouseover和mouseenter的区别")]),t._v(" "),a("p",[t._v("mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移除事件是mouseout")]),t._v(" "),a("p",[t._v("mouseenter：当鼠标移除元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，对应的移除事件是mouseleave")]),t._v(" "),a("h2",{attrs:{id:"解决异步回调地狱"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决异步回调地狱"}},[t._v("#")]),t._v(" 解决异步回调地狱")]),t._v(" "),a("p",[t._v("promise、generator、async/await")]),t._v(" "),a("h2",{attrs:{id:"对this对象的理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对this对象的理解"}},[t._v("#")]),t._v(" 对This对象的理解")]),t._v(" "),a("p",[t._v("this总是指向函数的直接调用者（而非间接调用者）")]),t._v(" "),a("p",[t._v("如果有new关键字，this指向new出来的那个对象")]),t._v(" "),a("p",[t._v("在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window")])])}],!1,null,null,null);a.default=v.exports}}]);