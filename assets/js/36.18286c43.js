(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{235:function(a,e,s){"use strict";s.r(e);var n=s(0),t=Object(n.a)({},(function(){var a=this,e=a.$createElement,s=a._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"题目"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#题目"}},[a._v("#")]),a._v(" 题目")]),a._v(" "),s("h2",{attrs:{id:"var、let、const之间的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#var、let、const之间的区别"}},[a._v("#")]),a._v(" var、let、const之间的区别")]),a._v(" "),s("p",[a._v("var声明变量可以重复声明，而let不可以重复声明")]),a._v(" "),s("p",[a._v("var是不受限于块级的，而let是受限于块级")]),a._v(" "),s("p",[a._v("var会与window相映射（会挂一个属性），而let不与window相映射")]),a._v(" "),s("p",[a._v("var可以在声明的上面访问变量，而let有暂存死区，在声明的上面访问变量会报错")]),a._v(" "),s("p",[a._v("const声明之后必须赋值，否则会报错")]),a._v(" "),s("p",[a._v("const定义不可变的量，改变了就会报错")]),a._v(" "),s("p",[a._v("const和let一样不会与window相映射、支持块级作用域、在声明的上面访问变量会报错")]),a._v(" "),s("h2",{attrs:{id:"解构赋值"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解构赋值"}},[a._v("#")]),a._v(" 解构赋值")]),a._v(" "),s("p",[a._v("数组解构")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("let [a, b, c] = [1, 2, 3]   //a=1, b=2, c=3\nlet [d, [e], f] = [1, [2], 3]    //嵌套数组解构 d=1, e=2, f=3\nlet [g, ...h] = [1, 2, 3]   //数组拆分 g=1, h=[2, 3]\nlet [i,,j] = [1, 2, 3]   //不连续解构 i=1, j=3\nlet [k,l] = [1, 2, 3]   //不完全解构 k=1, l=2\n")])])]),s("p",[a._v("对象解构")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("let {a, b} = {a: 'aaaa', b: 'bbbb'}      //a='aaaa' b='bbbb'\nlet obj = {d: 'aaaa', e: {f: 'bbbb'}}\nlet {d, e:{f}} = obj    //嵌套解构 d='aaaa' f='bbbb'\nlet g;\n(g = {g: 'aaaa'})   //以声明变量解构 g='aaaa'\nlet [h, i, j, k] = 'nice'    //字符串解构 h='n' i='i' j='c' k='e'\n")])])]),s("p",[a._v("函数参数的定义：")]),a._v(" "),s("p",[a._v("一般我们在定义函数的时候，如果函数有多个参数时，在es5语法中函数调用时参数必须一一对应，否则就会出现赋值错误的情况，来看一个例子：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("function personInfo(name, age, address, gender) {\n  console.log(name, age, address, gender)\n}\npersonInfo('william', 18, 'changsha', 'man')\n")])])]),s("p",[a._v("上面这个例子在对用户信息的时候需要传递四个参数，且需要一一对应，这样就会极易出现参数顺序传错的情况，从而导致bug，接下来来看es6解构赋值是怎么解决这个问题的：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("function personInfo({name, age, address, gender}) {\n  console.log(name, age, address, gender)\n}\npersonInfo({gender: 'man', address: 'changsha', name: 'william', age: 18})\n")])])]),s("p",[a._v("这么写我们只知道要传声明参数就行来，不需要知道参数的顺序也没关系")]),a._v(" "),s("p",[a._v("交换变量的值")]),a._v(" "),s("p",[a._v("在es5中我们需要交换两个变量的值需要借助临时变量的帮助，来看一个例子：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("var a=1, b=2, c\nc = a\na = b\nb = c\nconsole.log(a, b)\n")])])]),s("p",[a._v("来看es6怎么实现：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("let a=1, b=2;\n[b, a] = [a, b]\nconsole.log(a, b)\n")])])]),s("p",[a._v("是不是比es5的写法更加方便呢")]),a._v(" "),s("p",[a._v("函数默认参数：")]),a._v(" "),s("p",[a._v("在日常开发中，经常会有这种情况：函数的参数需要默认值，如果没有默认值在使用的时候就会报错，来看es5中是怎么做的：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("function saveInfo(name, age, address, gender) {\n  name = name || 'william'\n  age = age || 18\n  address = address || 'changsha'\n  gender = gender || 'man'\n  console.log(name, age, address, gender)\n}\nsaveInfo()\n")])])]),s("p",[a._v("在函数离 main先对参数做一个默认值赋值，然后再使用避免使用的过程中报错，再来看es6中的使用的方法：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("function saveInfo({name= 'william', age= 18, address= 'changsha', gender= 'man'} = {}) {\n  console.log(name, age, address, gender)\n}\nsaveInfo()\n")])])]),s("p",[a._v("在函数定义的时候就定义了默认参数，这样就免了后面给参数赋值默认值的过程，是不是看起来简单多了")]),a._v(" "),s("h2",{attrs:{id:"foreach、for-in、for-of三者区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#foreach、for-in、for-of三者区别"}},[a._v("#")]),a._v(" forEach、for in、for of三者区别")]),a._v(" "),s("p",[a._v("forEach更多的用来遍历数")]),a._v(" "),s("p",[a._v("for in 一般常用来遍历对象或json")]),a._v(" "),s("p",[a._v("for of数组对象都可以遍历，遍历对象需要通过和Object.keys()")]),a._v(" "),s("p",[a._v("for in循环出的是key，for of循环出的是value")]),a._v(" "),s("h2",{attrs:{id:"使用箭头函数应注意什么？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用箭头函数应注意什么？"}},[a._v("#")]),a._v(" 使用箭头函数应注意什么？")]),a._v(" "),s("p",[a._v("1、用了箭头函数，this就不是指向window，而是父级（指向是可变的）"),s("br"),a._v("\n2、不能够使用arguments对象"),s("br"),a._v("\n3、不能用作构造函数，这就是说不能够使用new命令，否则会抛出一个错误"),s("br"),a._v("\n4、不可以使用yield命令，因此箭头函数不能用作 Generator 函数")]),a._v(" "),s("h2",{attrs:{id:"set、map的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#set、map的区别"}},[a._v("#")]),a._v(" Set、Map的区别")]),a._v(" "),s("p",[a._v("应用场景Set用于数据重组，Map用于数据储存")]),a._v(" "),s("p",[a._v("Set：")]),a._v(" "),s("p",[a._v("1，成员不能重复"),s("br"),a._v("\n2，只有键值没有键名，类似数组"),s("br"),a._v("\n3，可以遍历，方法有add, delete,has")]),a._v(" "),s("p",[a._v("Map:")]),a._v(" "),s("p",[a._v("1，本质上是健值对的集合，类似集合"),s("br"),a._v("\n2，可以遍历，可以跟各种数据格式转换")]),a._v(" "),s("h2",{attrs:{id:"promise对象的用法-手写一个promise"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise对象的用法-手写一个promise"}},[a._v("#")]),a._v(" promise对象的用法,手写一个promise")]),a._v(" "),s("p",[a._v("promise是一个构造函数，下面是一个简单实例")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("var promise = new Promise((resolve,reject) => {\n    if (操作成功) {\n        resolve(value)\n    } else {\n        reject(error)\n    }\n})\npromise.then(function (value) {\n    // success\n},function (value) {\n    // failure\n})\n\n")])])])])}),[],!1,null,null,null);e.default=t.exports}}]);