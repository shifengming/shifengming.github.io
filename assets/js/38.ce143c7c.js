(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{209:function(t,e,n){"use strict";n.r(e);var a=n(0),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"vue3-0新特性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vue3-0新特性"}},[t._v("#")]),t._v(" Vue3.0新特性")]),t._v(" "),n("h2",{attrs:{id:"vue3-0简介"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vue3-0简介"}},[t._v("#")]),t._v(" vue3.0简介")]),t._v(" "),n("p",[t._v("可以查看网址")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("https://www.liulongbin.top/\n")])])]),n("h2",{attrs:{id:"初始化项目"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#初始化项目"}},[t._v("#")]),t._v(" 初始化项目")]),t._v(" "),n("blockquote",[n("p",[t._v("检查 node 环境配置")])]),t._v(" "),n("p",[t._v("先本地全局安装node环境，vue的运行是依赖于"),n("code",[t._v("node")]),t._v("的"),n("code",[t._v("npm")]),t._v("的管理工具来实现的，"),n("a",{attrs:{href:"https://nodejs.org/en/",target:"_blank",rel:"noopener noreferrer"}},[t._v("node下载地址"),n("OutboundLink")],1),t._v("。下载好node之后，打开cmd管理工具，输入"),n("code",[t._v("node -v")]),t._v("，回车，查看node版本号，出现版本号则说明安装成功，注意：node 的版本要在 8.9  或更高版本 (推荐 8.11.0+)")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("node -v  npm -v\n")])])]),n("blockquote",[n("p",[t._v("Vue 版本")])]),t._v(" "),n("ul",[n("li",[t._v("关于旧版本")])]),t._v(" "),n("p",[t._v("如果你已经全局安装了旧版本的 vue-cli (1.x 或 2.x)，你需要先通过 npm uninstall vue-cli -g 或 yarn global remove vue-cli 卸载它, Vue CLI 的包名称由 vue-cli 改成了 @vue/cli。")]),t._v(" "),n("ul",[n("li",[t._v("安装新版本")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("npm install -g @vue/cli\n# OR\nyarn global add @vue/cli\n")])])]),n("ul",[n("li",[t._v("查看版本")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("vue --version | vue -V\n")])])]),n("blockquote",[n("p",[t._v("创建项目")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("vue create mc-ui\nOR\nvue ui 也可以使用UI图形化界面创建项目\n")])])]),n("p",[t._v("注意：由于我们是开发一个第三方依赖库，我们选择 Manually select features。")]),t._v(" "),n("ol",[n("li",[t._v("选择那些特性需要安装在项目中")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v(" (*) Babel\n ( ) TypeScript\n ( ) Progressive Web App (PWA) Support\n ( ) Router\n ( ) Vuex\n (*) CSS Pre-processors\n (*) Linter / Formatter\n ( ) Unit Testing\n ( ) E2E Testing\n")])])]),n("p",[t._v("系统默认的包含了基本的 Babel + ESLint 设置的 preset，我们只需要选择CSS配置。移动键盘上下键选择需要的特性，按下键盘空格键即可选中")]),t._v(" "),n("ol",{attrs:{start:"2"}},[n("li",[t._v("安装哪一种 CSS 预处理语言")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("  Sass/SCSS (with dart-sass)\n  Sass/SCSS (with node-sass)\n  Less\n  Stylus\n")])])]),n("p",[t._v("由于Element UI中的样式采用Sass，所以我们选择第一项即可\n为什么不选择第二项呢？\n因为dart-sass比node-sass更好下载")]),t._v(" "),n("ol",{attrs:{start:"3"}},[n("li",[t._v("选择代码风格")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("  ESLint with error prevention only\n  ESLint + Airbnb config\n  ESLint + Standard config\n  ESLint + Prettier\n")])])]),n("p",[t._v("因个人喜好选择即可，我比较喜欢第三种")]),t._v(" "),n("ol",{attrs:{start:"4"}},[n("li",[t._v("那种方式进行代码格式检测")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v(" (*) Lint on save\n ( ) Lint and fix on commit\n")])])]),n("p",[t._v("选择Ctrl+S保存时检测代码格式即可")]),t._v(" "),n("ol",{attrs:{start:"5"}},[n("li",[t._v("配置文件生成方式")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("  In dedicated config files\n  In package.json\n")])])]),n("p",[t._v("因个人喜好，我比较喜欢选择第二种")]),t._v(" "),n("ol",{attrs:{start:"6"}},[n("li",[t._v("是否保存预配置")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("Save this as a preset for future projects? (y/N)\n")])])]),n("p",[t._v("看项目需要，我这里选择 N。回车后，系统会自动帮我们把选择的配置集成到模板中，然后生成一个完整的项目。")]),t._v(" "),n("h2",{attrs:{id:"安装一些新特性的api"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#安装一些新特性的api"}},[t._v("#")]),t._v(" 安装一些新特性的API")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("npm install @vue/composition-api --save\n")])])]),n("p",[t._v("然后再到main.js里面引入")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import VueCompositionAPI from '@vue/composition-api'\n\nVue.use(VueCompositionAPI)\n")])])]),n("h2",{attrs:{id:"setup"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#setup"}},[t._v("#")]),t._v(" setup")]),t._v(" "),n("p",[t._v("setup() 函数是 vue3 中，专门为组件提供的新属性。它为我们使用 vue3 的 Composition API 新特性提供了统一的入口")]),t._v(" "),n("p",[t._v("setup 函数会在 beforeCreate 之后、created 之前执行")]),t._v(" "),n("h3",{attrs:{id:"编写代码实践"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#编写代码实践"}},[t._v("#")]),t._v(" 编写代码实践")]),t._v(" "),n("p",[t._v("App.vue")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("<template>\n  <div>\n    <com-setup></com-setup>\n  </div>\n</template>\n\n<script>\nimport SetUpCom from './components/setup.vue'\nexport default {\n  name: 'App',\n  components: {\n    'com-setup':SetUpCom\n  }\n}\n<\/script>\n")])])]),n("p",[t._v("setup.vue")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("<template>\n    <div>\n\n    </div>\n</template>\n<script>\n    import {} from '@vue/composition-api'\n\n    export default{\n        setup(){\n            console.log('setup')\n        },\n        beforeCreate(){\n            console.log('beforeCreate')\n        },\n        created(){\n            console.log('created')\n        }\n    }\n<\/script>\n")])])]),n("p",[t._v("运行的结果")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("beforeCreate\nsetup\ncreated\n")])])]),n("h2",{attrs:{id:"接受props数据"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#接受props数据"}},[t._v("#")]),t._v(" 接受props数据")]),t._v(" "),n("p",[t._v("setup.vue")]),t._v(" "),n("p",[t._v("在 props 中定义当前组件允许外界传递过来的参数名称")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("props:{\n\tp1: String\n}\n")])])]),n("p",[t._v("通过 setup 函数的第一个形参，接收 props 数据")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("setup(props){\n            console.log('setup')\n            console.log(props)\n        },\n")])])]),n("p",[t._v("App.vue")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('<com-setup p1="aaaaa"></com-setup>\n')])])]),n("p",[n("img",{attrs:{src:"http://r.photo.store.qq.com/psc?/V121VjTP2yfy1N/uMeul31pGB4ZvQm8Ou4xcWEoVT6LfDP6fSpEQTpXimhF2VEP9pkdICwW56RnRsQHMb2j1BpxQgOG3OXoRda8Mc7i4bl7zDuuAF6iVkB*gpo!/r",alt:""}})]),t._v(" "),n("h2",{attrs:{id:"context"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#context"}},[t._v("#")]),t._v(" context")]),t._v(" "),n("p",[t._v("setup 函数的第二个形参是一个上下文对象，这个上下文对象中包含了一些有用的属性，这些属性在 vue 2.x 中需要通过 this 才能访问到，在 vue 3.x 中，它们的访问方式如下：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("        setup(props,ctx){\n            console.log('setup')\n            console.log(ctx)\n        },\n")])])]),n("p",[n("img",{attrs:{src:"http://r.photo.store.qq.com/psc?/V121VjTP2yfy1N/uMeul31pGB4ZvQm8Ou4xcYJpxItuRUqyV7ScuY8XUQPI4e*tqpI1jzZEWoavHU24iFOsPW*JIaQ6YKkLlfnyjq5*cATUibwxlYL7*IasQJw!/r",alt:""}})]),t._v(" "),n("h2",{attrs:{id:"reactive"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#reactive"}},[t._v("#")]),t._v(" reactive")]),t._v(" "),n("p",[t._v("reactive()函数接收一个普通对象，返回一个响应式的数据对象")]),t._v(" "),n("p",[t._v("components/setup.vue")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("    <div>\n        <p>count值为{{count}}</p>\n        <button @click=\"count+=1\">+1</button>\n    </div>\n    \n    import {reactive} from '@vue/composition-api'\n    export default{\n        setup(props,ctx){\n            console.log(ctx)\n            console.log(props)\n            const state = reactive({count: 0})\n            return state\n        },\n      } \n")])])]),n("p",[n("img",{attrs:{src:"http://r.photo.store.qq.com/psc?/V121VjTP2yfy1N/uMeul31pGB4ZvQm8Ou4xccDWfLne3rlzz*JKlHU*cKOfeCiW47hnpVb36tR0Zzmfe4J1p3FHxnEuReWAcCQJNpXesbO81GJ1Fvs457yYnW4!/r",alt:""}})]),t._v(" "),n("h2",{attrs:{id:"ref"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ref"}},[t._v("#")]),t._v(" ref")]),t._v(" "),n("p",[t._v("ref() 函数用来根据给定的值创建一个响应式的数据对象，ref() 函数调用的返回值是一个对象，这个对象上只包含一个 .value 属性：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('<template>\n    <div>\n        <p>count的值为{{refCount}}</p>\n        <button @click="refCount+=1">+1</button>\n    </div>\n</template>\n<script>\nimport {ref} from "@vue/composition-api"\n    export default{\n        setup(){\n            const refCount = ref(0);\n            console.log(refCount.value)\n\n            return {\n                refCount\n            }\n        }\n    }\n<\/script>\n')])])]),n("p",[n("img",{attrs:{src:"http://r.photo.store.qq.com/psc?/V121VjTP2yfy1N/uMeul31pGB4ZvQm8Ou4xccDWfLne3rlzz*JKlHU*cKOfeCiW47hnpVb36tR0Zzmfe4J1p3FHxnEuReWAcCQJNpXesbO81GJ1Fvs457yYnW4!/r",alt:""}})]),t._v(" "),n("h2",{attrs:{id:"isref"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#isref"}},[t._v("#")]),t._v(" isRef")]),t._v(" "),n("p",[t._v("isRef() 用来判断某个值是否为 ref() 创建出来的对象；应用场景：当需要展开某个可能为 ref() 创建出来的值的时候")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import { isRef } from '@vue/composition-api'\n\nconst unwrapped = isRef(foo) ? foo.value : foo\n")])])]),n("h2",{attrs:{id:"torefs"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#torefs"}},[t._v("#")]),t._v(" toRefs")]),t._v(" "),n("p",[t._v("toRefs() 函数可以将 reactive() 创建出来的响应式对象，转换为普通的对象，只不过，这个对象上的每个属性节点，都是 ref() 类型的响应式数据，最常见的应用场景如下")]),t._v(" "),n("p",[t._v("ref.vue")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('<template>\n    <div>\n        <p>count的值为{{refCount}}</p>\n        <button @click="refCount+=1">+1</button>\n    </div>\n</template>\n<script>\nimport {ref} from "@vue/composition-api"\n    export default{\n        setup(){\n            const refCount = ref(0);\n            console.log(refCount.value)\n\n            return {\n                refCount\n            }\n        }\n    }\n<\/script>\n')])])]),n("p",[n("img",{attrs:{src:"http://r.photo.store.qq.com/psc?/V121VjTP2yfy1N/uMeul31pGB4ZvQm8Ou4xccDWfLne3rlzz*JKlHU*cKOfeCiW47hnpVb36tR0Zzmfe4J1p3FHxnEuReWAcCQJNpXesbO81GJ1Fvs457yYnW4!/r",alt:""}})]),t._v(" "),n("h2",{attrs:{id:"computed"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#computed"}},[t._v("#")]),t._v(" computed")]),t._v(" "),n("p",[t._v("computed() 用来创建计算属性，computed() 函数的返回值是一个 ref 的实例。使用 computed 之前需要按需导入：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import { computed } from '@vue/composition-api'\n")])])]),n("h3",{attrs:{id:"创建只读的计算属性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#创建只读的计算属性"}},[t._v("#")]),t._v(" 创建只读的计算属性")]),t._v(" "),n("p",[t._v("在调用 computed() 函数期间，传入一个 function 函数，可以得到一个只读的计算属性，示例代码如下:")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("<p>count值为:{{refCount}}</p>\n<p>计算属性的值:{{computedCount}}</p>\n<button @click=\"refCount+=1\"></button>\n\nimport {ref,computed} from '@vue/composition-api'\nexport default{\n\tsetup(){\n\t\tconst refCount = ref(0);\n\t\t\n\t\tconst computedCount = computed(() =refCount.value+1)\n\t\t\n\t\treturn {\n\t\t\trefCount,\n\t\t\tcomputedCount\n\t\t}\n\t}\n}\n")])])]),n("h3",{attrs:{id:"创建可读可写的计算属性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#创建可读可写的计算属性"}},[t._v("#")]),t._v(" 创建可读可写的计算属性")]),t._v(" "),n("p",[t._v("在调用 computed() 函数期间，传入一个包含 get 和 set 函数的对象，可以得到一个可读可写的计算属性，示例代码如下：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// 创建一个 ref 响应式数据\nconst count = ref(1)\n\n// 创建一个 computed 计算属性\nconst plusOne = computed({\n  // 取值函数\n  get: () => count.value + 1,\n  // 赋值函数\n  set: val => {\n    count.value = val - 1\n  }\n})\n\n// 为计算属性赋值的操作，会触发 set 函数\nplusOne.value = 9\n// 触发 set 函数后，count 的值会被更新\nconsole.log(count.value) // 输出 8\n")])])]),n("h2",{attrs:{id:"watch"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#watch"}},[t._v("#")]),t._v(" watch")]),t._v(" "),n("p",[t._v("watch() 函数用来监视某些数据项的变化，从而触发某些特定的操作，使用之前需要按需导入")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import { watch } from '@vue/composition-api'\n")])])]),n("h3",{attrs:{id:"基础用法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#基础用法"}},[t._v("#")]),t._v(" 基础用法")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const count = ref(0)\n\n// 定义 watch，只要 count 值变化，就会触发 watch 回调\n// watch 会在创建时会自动调用一次\nwatch(() => console.log(count.value))\n// 输出 0\n\nsetTimeout(() => {\n  count.value++\n  // 输出 1\n}, 1000)\n")])])]),n("h3",{attrs:{id:"监听指定的数据源"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#监听指定的数据源"}},[t._v("#")]),t._v(" 监听指定的数据源")]),t._v(" "),n("p",[t._v("监视 reactive 类型的数据源：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// 定义数据源\nconst state = reactive({ count: 0 })\n// 监视 state.count 这个数据节点的变化\nwatch(\n  () => state.count,\n  (count, prevCount) => {\n    /* ... */\n  }\n)\n")])])]),n("p",[t._v("监视 "),n("code",[t._v("ref")]),t._v(" 类型的数据源：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// 定义数据源\nconst count = ref(0)\n// 指定要监视的数据源\nwatch(count, (count, prevCount) => {\n  /* ... */\n})\n")])])]),n("h3",{attrs:{id:"监听多个数据源"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#监听多个数据源"}},[t._v("#")]),t._v(" 监听多个数据源")]),t._v(" "),n("p",[t._v("监视 "),n("code",[t._v("reactive")]),t._v(" 类型的数据源：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const state = reactive({ count: 0, name: 'zs' })\n\nwatch(\n  [() => state.count, () => state.name], // Object.values(toRefs(state)),\n  ([count, name], [prevCount, prevName]) => {\n    console.log(count) // 新的 count 值\n    console.log(name) // 新的 name 值\n    console.log('------------')\n    console.log(prevCount) // 旧的 count 值\n    console.log(prevName) // 新的 name 值\n  },\n  {\n    lazy: true // 在 watch 被创建的时候，不执行回调函数中的代码\n  }\n)\n\nsetTimeout(() => {\n  state.count++\n  state.name = 'ls'\n}, 1000)\n")])])]),n("p",[t._v("监视 "),n("code",[t._v("ref")]),t._v(" 类型的数据源：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const count = ref(0)\nconst name = ref('zs')\n\nwatch(\n  [count, name], // 需要被监视的多个 ref 数据源\n  ([count, name], [prevCount, prevName]) => {\n    console.log(count)\n    console.log(name)\n    console.log('-------------')\n    console.log(prevCount)\n    console.log(prevName)\n  },\n  {\n    lazy: true\n  }\n)\n\nsetTimeout(() => {\n  count.value++\n  name.value = 'xiaomaolv'\n}, 1000)\n")])])]),n("h3",{attrs:{id:"清除监听"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#清除监听"}},[t._v("#")]),t._v(" 清除监听")]),t._v(" "),n("p",[t._v("在 setup() 函数内创建的 watch 监视，会在当前组件被销毁的时候自动停止。如果想要明确地停止某个监视，可以调用 watch() 函数的返回值即可，语法如下：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// 创建监视，并得到 停止函数\nconst stop = watch(() => {\n  /* ... */\n})\n\n// 调用停止函数，清除对应的监视\nstop()\n")])])]),n("h3",{attrs:{id:"在watch清除无效的异步任务"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#在watch清除无效的异步任务"}},[t._v("#")]),t._v(" 在watch清除无效的异步任务")]),t._v(" "),n("p",[t._v("有时候，当被 watch 监视的值发生变化时，或 watch 本身被 stop 之后，我们期望能够清除那些无效的异步任务，此时，watch 回调函数中提供了一个 cleanup registrator function 来执行清除的工作。这个清除函数会在如下情况下被调用：")]),t._v(" "),n("p",[t._v("watch 被重复执行了\nwatch 被强制 stop 了")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('/* template 中的代码 */ <input type="text" v-model="keywords" />\n')])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// 定义响应式数据 keywords\nconst keywords = ref('')\n\n// 异步任务：打印用户输入的关键词\nconst asyncPrint = val => {\n  // 延时 1 秒后打印\n  return setTimeout(() => {\n    console.log(val)\n  }, 1000)\n}\n\n// 定义 watch 监听\nwatch(\n  keywords,\n  (keywords, prevKeywords, onCleanup) => {\n    // 执行异步任务，并得到关闭异步任务的 timerId\n    const timerId = asyncPrint(keywords)\n\n    // 如果 watch 监听被重复执行了，则会先清除上次未完成的异步任务\n    onCleanup(() => clearTimeout(timerId))\n  },\n  // watch 刚被创建的时候不执行\n  { lazy: true }\n)\n\n// 把 template 中需要的数据 return 出去\nreturn {\n  keywords\n}\n")])])]),n("h2",{attrs:{id:"生命周期"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[t._v("#")]),t._v(" 生命周期")]),t._v(" "),n("p",[t._v("LifeCycle Hooks")]),t._v(" "),n("p",[t._v("是 vue 2.x 的生命周期函数与新版 Composition API 之间的映射关系：")]),t._v(" "),n("ul",[n("li",[n("s",[n("code",[t._v("beforeCreate")])]),t._v(" -> use "),n("code",[t._v("setup()")])]),t._v(" "),n("li",[n("s",[n("code",[t._v("created")])]),t._v(" -> use "),n("code",[t._v("setup()")])]),t._v(" "),n("li",[n("code",[t._v("beforeMount")]),t._v(" -> "),n("code",[t._v("onBeforeMount")])]),t._v(" "),n("li",[n("code",[t._v("mounted")]),t._v(" -> "),n("code",[t._v("onMounted")])]),t._v(" "),n("li",[n("code",[t._v("beforeUpdate")]),t._v(" -> "),n("code",[t._v("onBeforeUpdate")])]),t._v(" "),n("li",[n("code",[t._v("updated")]),t._v(" -> "),n("code",[t._v("onUpdated")])]),t._v(" "),n("li",[n("code",[t._v("beforeDestroy")]),t._v(" -> "),n("code",[t._v("onBeforeUnmount")])]),t._v(" "),n("li",[n("code",[t._v("destroyed")]),t._v(" -> "),n("code",[t._v("onUnmounted")])]),t._v(" "),n("li",[n("code",[t._v("errorCaptured")]),t._v(" -> "),n("code",[t._v("onErrorCaptured")])])]),t._v(" "),n("p",[t._v("发生ajax请求都是在mounted里面调用")]),t._v(" "),n("p",[t._v("新版的生命周期函数，可以按需导入到组件中，且只能在 setup() 函数中使用，代码示例如下：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import { onMounted, onUpdated, onUnmounted } from '@vue/composition-api'\n\nconst MyComponent = {\n  setup() {\n    onMounted(() => {\n      console.log('mounted!')\n    })\n    onUpdated(() => {\n      console.log('updated!')\n    })\n    onUnmounted(() => {\n      console.log('unmounted!')\n    })\n  }\n}\n")])])]),n("h2",{attrs:{id:"provide-inject"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#provide-inject"}},[t._v("#")]),t._v(" provide&inject")]),t._v(" "),n("p",[t._v("provide() 和 inject() 可以实现嵌套组件之间的数据传递。这两个函数只能在 setup() 函数中使用。父级组件中使用 provide() 函数向下传递数据；子级组件中使用 inject() 获取上层传递过来的数据")]),t._v(" "),n("h3",{attrs:{id:"共享普通数据"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#共享普通数据"}},[t._v("#")]),t._v(" 共享普通数据")]),t._v(" "),n("p",[t._v("App.vue 根组件：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("<template>\n  <div id=\"app\">\n    <h1>App 根组件</h1>\n    <hr />\n    <LevelOne />\n  </div>\n</template>\n\n<script>\nimport LevelOne from './components/LevelOne'\n// 1. 按需导入 provide\nimport { provide } from '@vue/composition-api'\n\nexport default {\n  name: 'app',\n  setup() {\n    // 2. App 根组件作为父级组件，通过 provide 函数向子级组件共享数据（不限层级）\n    //    provide('要共享的数据名称', 被共享的数据)\n    provide('globalColor', 'red')\n  },\n  components: {\n    LevelOne\n  }\n}\n<\/script>\n")])])]),n("p",[t._v("LevelOne.vue 组件：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("<template>\n  <div>\n    \x3c!-- 4. 通过属性绑定，为标签设置字体颜色 --\x3e\n    <h3 :style=\"{color: themeColor}\">Level One</h3>\n    <hr />\n    <LevelTwo />\n  </div>\n</template>\n\n<script>\nimport LevelTwo from './LevelTwo'\n// 1. 按需导入 inject\nimport { inject } from '@vue/composition-api'\n\nexport default {\n  setup() {\n    // 2. 调用 inject 函数时，通过指定的数据名称，获取到父级共享的数据\n    const themeColor = inject('globalColor')\n\n    // 3. 把接收到的共享数据 return 给 Template 使用\n    return {\n      themeColor\n    }\n  },\n  components: {\n    LevelTwo\n  }\n}\n<\/script>\n")])])]),n("p",[t._v("LevelTwo.vue 组件：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("<template>\n  <div>\n    \x3c!-- 4. 通过属性绑定，为标签设置字体颜色 --\x3e\n    <h5 :style=\"{color: themeColor}\">Level Two</h5>\n  </div>\n</template>\n\n<script>\n// 1. 按需导入 inject\nimport { inject } from '@vue/composition-api'\n\nexport default {\n  setup() {\n    // 2. 调用 inject 函数时，通过指定的数据名称，获取到父级共享的数据\n    const themeColor = inject('globalColor')\n\n    // 3. 把接收到的共享数据 return 给 Template 使用\n    return {\n      themeColor\n    }\n  }\n}\n<\/script>\n")])])]),n("h3",{attrs:{id:"共享ref响应式数据"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#共享ref响应式数据"}},[t._v("#")]),t._v(" 共享ref响应式数据")]),t._v(" "),n("p",[t._v("如下代码实现了点按钮切换主题颜色的功能，主要修改了 App.vue 组件中的代码，LevelOne.vue 和 LevelTwo.vue 中的代码不受任何改变：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("<template>\n  <div id=\"app\">\n    <h1>App 根组件</h1>\n\n    \x3c!-- 点击 App.vue 中的按钮，切换子组件中文字的颜色 --\x3e\n    <button @click=\"themeColor='red'\">红色</button>\n    <button @click=\"themeColor='blue'\">蓝色</button>\n    <button @click=\"themeColor='orange'\">橘黄色</button>\n\n    <hr />\n    <LevelOne />\n  </div>\n</template>\n\n<script>\nimport LevelOne from './components/LevelOne'\nimport { provide, ref } from '@vue/composition-api'\n\nexport default {\n  name: 'app',\n  setup() {\n    // 定义 ref 响应式数据\n    const themeColor = ref('red')\n\n    // 把 ref 数据通过 provide 提供的子组件使用\n    provide('globalColor', themeColor)\n\n    // setup 中 return 数据供当前组件的 Template 使用\n    return {\n      themeColor\n    }\n  },\n  components: {\n    LevelOne\n  }\n}\n<\/script>\n")])])]),n("h2",{attrs:{id:"ref引用dom元素和组件实例"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ref引用dom元素和组件实例"}},[t._v("#")]),t._v(" ref引用DOM元素和组件实例")]),t._v(" "),n("p",[t._v("通过 ref() 还可以引用页面上的元素或组件")]),t._v(" "),n("h3",{attrs:{id:"元素的引用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#元素的引用"}},[t._v("#")]),t._v(" 元素的引用")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("<template>\n  <div>\n    <h3 ref=\"h3Ref\">TemplateRefOne</h3>\n  </div>\n</template>\n\n<script>\nimport { ref, onMounted } from '@vue/composition-api'\n\nexport default {\n  setup() {\n    // 创建一个 DOM 引用\n    const h3Ref = ref(null)\n\n    // 在 DOM 首次加载完毕之后，才能获取到元素的引用\n    onMounted(() => {\n      // 为 dom 元素设置字体颜色\n      // h3Ref.value 是原生DOM对象\n      h3Ref.value.style.color = 'red'\n    })\n\n    // 把创建的引用 return 出去\n    return {\n      h3Ref\n    }\n  }\n}\n<\/script>\n")])])]),n("h3",{attrs:{id:"组件的引用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#组件的引用"}},[t._v("#")]),t._v(" 组件的引用")]),t._v(" "),n("p",[t._v("TemplateRefOne.vue 中的示例代码如下：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("<template>\n  <div>\n    <h3>TemplateRefOne</h3>\n\n    \x3c!-- 4. 点击按钮展示子组件的 count 值 --\x3e\n    <button @click=\"showNumber\">获取TemplateRefTwo中的count值</button>\n\n    <hr />\n    \x3c!-- 3. 为组件添加 ref 引用 --\x3e\n    <TemplateRefTwo ref=\"comRef\" />\n  </div>\n</template>\n\n<script>\nimport { ref } from '@vue/composition-api'\nimport TemplateRefTwo from './TemplateRefTwo'\n\nexport default {\n  setup() {\n    // 1. 创建一个组件的 ref 引用\n    const comRef = ref(null)\n\n    // 5. 展示子组件中 count 的值\n    const showNumber = () => {\n      console.log(comRef.value.count)\n    }\n\n    // 2. 把创建的引用 return 出去\n    return {\n      comRef,\n      showNumber\n    }\n  },\n  components: {\n    TemplateRefTwo\n  }\n}\n<\/script>\n")])])]),n("p",[t._v("TemplateRefTwo.vue 中的示例代码：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("<template>\n  <div>\n    <h5>TemplateRefTwo --- {{count}}</h5>\n    \x3c!-- 3. 点击按钮，让 count 值自增 +1 --\x3e\n    <button @click=\"count+=1\">+1</button>\n  </div>\n</template>\n\n<script>\nimport { ref } from '@vue/composition-api'\n\nexport default {\n  setup() {\n    // 1. 定义响应式的数据\n    const count = ref(0)\n\n    // 2. 把响应式数据 return 给 Template 使用\n    return {\n      count\n    }\n  }\n}\n<\/script>\n")])])]),n("h2",{attrs:{id:"createcomponent"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#createcomponent"}},[t._v("#")]),t._v(" createComponent")]),t._v(" "),n("p",[t._v("这个函数不是必须的，除非你想要完美结合 TypeScript 提供的类型推断来进行项目的开发")]),t._v(" "),n("p",[t._v("这个函数仅仅提供了类型推断，方便在结合 TypeScript 书写代码时，能为 setup() 中的 props 提供完整的类型推断")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import { createComponent } from 'vue'\n\nexport default createComponent({\n  props: {\n    foo: String\n  },\n  setup(props) {\n    props.foo // <- type: string\n  }\n})\n")])])]),n("h2",{attrs:{id:"nexttick的作用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#nexttick的作用"}},[t._v("#")]),t._v(" $nextTick的作用")]),t._v(" "),n("p",[t._v("当组件具最新的data数据  重新渲染完成之后 再执行回调函数中的操作，需要用到nextTick不会报错")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('<template>\n    <div>\n        <h1>学习nextTick</h1>\n        <button v-if="isShowInput === false" @click="showInput">展示文本框</button>\n        <input type="text" v-else ref="ipt">\n    </div>\n</template>\n<script>\nexport default{\n    data(){\n        return{\n            isShowInput: false\n        }\n    },\n    methods:{\n        showInput(){\n            this.isShowInput = true;\n            // this.$refs.ipt.focus();\n            //当组件更具最新的data数据  重新渲染完成之后 再执行回调函数中的操作\n            this.$nextTick(() =>{\n                this.$refs.ipt.focus();\n            })\n        }\n    }\n}\n<\/script>\n')])])]),n("h2",{attrs:{id:"实现响应式源码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#实现响应式源码"}},[t._v("#")]),t._v(" 实现响应式源码")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("<script>\n\tfunction usePosition(){\n\t\tlet position = Vue.reactive({x:0,y:0});\n\t\tfunction update(e){\n\t\t\tposition.x=e.pageX;\n\t\t\tposition.y=e.pageY;\n\t\t}\n\t\tVue.onmounted(()=>{\n\t\t\twindow.addEventListener('mousemove',update)\n\t\t})\n\t\tVue.onUnmounted(()=>{\n\t\t\twindow.addEventListener('mousemove',update)\n\t\t});\n\t\treturn Vue.toRefs(position);\n\t}\n\t//我们要获取鼠标的位置 这个功能在很多地方都需要被复用\n\t//composition api多个方法进行组合来使用\n\tconst App = {\n\t\tsetup(){\n\t\t\tlet state = Vue.reactive({name:'xiaoming'});\n\t\t\tlet postion = usePosition();\n\t\t\tfunction change(){\n\t\t\t  state.name = 'xiaoai'\n\t\t\t}\n\t\t\treturn {//这个对象会作为渲染的上下文\n\t\t\t  state,\n\t\t\t  change\n\t\t\t}\n\t\t}\n\t\ttemplate:'<div @click=\"change\">{{state.name}}</div>'\n\t}\n<\/script>\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("//Vue2.0  vue如何实现响应式原理\n//数据变化了，可以更新视图\nlet oldArrayPrototype = Array.prototype;\nlet proto = Object.create(oldArrayPrototype);//继承\n['push','shift','unshift'].forEach(method=>{\n\tproto[method] = function(){//函数劫持  把函数进行重写 内部 继续调用老的方法\n\t\tupdateView();//切片编程\n\t\toldArrayPrototype[method].call(this,...arguments)\n\t}\n})\nfunction observer(targer){\n\tif(typeof target !=== 'object' && target == null){\n\t\treturn target;\n\t}\n\tif(Array.isArray(target)){//拦截数组  给数组的方法进行重写\n\t\tObject.setProtoOf(target,proto);//写个循环  赋予给target\n\t}\n\tfor(let key in target){\n\t\tdefineReactive({target,key,target[key]});\n\t}\n}\nfunction definReactive(target,key,value){\n\tobserve(value);//递归  如果这个value值也是对象的话  我就将这个歌对象继续拦截\n\tObject.defineProperty(target,key,{\n\t\tget(){//get中会进行依赖收集\n\t\t\treturn value\n\t\t}\n\t\tset(newValue){\n\t\t\tif(newValue !== value){\n\t\t\t\tupdateView();\n\t\t\t\tvalue = newValue\n\t\t\t}\n\t\t}\n\t})\n}\n//如果属性不存在 新增的属性 会是响应式的吗？\nfunction updateView(){\n\tconsole.log('更新视图')\n}\n//使用Object.defineProperty 就是可以重新定义属性 给属性提娜佳getter和setter\nlet data = {name:'xiaoming',age:[1,2,3]};\nobserver(data);\ndata.age.push(4);//需要对数组上的方法进行重写 push shift unshift pop push reserse\n//data.name='xiaoai'\nconsole.log(data.name)\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("<script>\n\tlet proxy = Vue.reactive({name: 'xiaoming'});\n\t//副作用\n\tVue.effect(()=>{\n\t\tconsole.log(proxy.name)//xiaoming  xiaoai\n\t})\n\tproxy.name = 'xiaoai';\n<\/script>\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("//vue3.0响应式原理\n//1.    2.0会默认盒递归\n//2.    数组改变length  是无效的\n//3.    对象不存在的属性不能被拦截\n//判断是不是对象\nfunction isObject(val){\n\treturn typeof val === 'object' && val !== null;\n}\n//响应式的核心方法\nfunctio reactive(target){\n\t//创建响应式对象\n\treturn createReactiveObject(target);\n}\n//创建响应式对象的\nfunction createRetiveObject(target){\n\tif(!isObject){//如果当前不是对象  直接返回即可\n\t\t return target;\n\t}\n\tlet baseHandler = {\n\t\t//reflect有点 不会报错 而且会有返回值 会替代掉Object上的方法\n\t\tget(target,key,receiver){\n\t\t\t//proxy+reflect反射\n\t\t\tconsole.log('获取')\n\t\t\tlet result = Reflect.get(target,key,receiver)\n\t\t\treturn result;\n\t\t},\n\t\tset(target,key,value,re){\n\t\t\t//如果设置没成功，如果这个对象不可以被更改 writable\n\t\t\tlet res = Reflect.set(target,key,value,receiver);\n\t\t\tconsole.log('设置')\n\t\t\treturn res;\n\t\t},\n\t\tdeleteProperty(target,key){\n\t\t\tlet res = Reflect.deleteProperty(target,key)\n\t\t\tconsole.log('删除')\n\t\t\treturn res;\n\t\t}\n\t}\n\tlet observed = new Proxy(target,baseHandler);//es6\n\treturn observed;\n}\n//代理对象\nlet proxy = reactive({name:'xiaoming'})\nproxy.name\nproxy.name='123'\ndelete.proxy.name\n")])])])])}),[],!1,null,null,null);e.default=s.exports}}]);