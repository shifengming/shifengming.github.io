(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{226:function(t,a,e){"use strict";e.r(a);var s=e(0),r=Object(s.a)({},(function(){this._self._c;return this._m(0)}),[function(){var t=this,a=t._self._c;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"重点题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重点题"}},[t._v("#")]),t._v(" 重点题")]),t._v(" "),a("h3",{attrs:{id:"生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[t._v("#")]),t._v(" 生命周期")]),t._v(" "),a("h3",{attrs:{id:"mount（加载阶段）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mount（加载阶段）"}},[t._v("#")]),t._v(" Mount（加载阶段）")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("constructor()\t加载的时候调用一次，可以初始化state，接受两个参数：props和context\nrender() \t挂载渲染组件\ncomponentDidMount()\t组件第一次渲染已经完成，此时DOM节点已经生成，可在这调用ajax请求，返回数据SetState后组件会重新渲染(Ajax请求应该在这个函数进行)\n")])])]),a("h3",{attrs:{id:"update（更新阶段）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#update（更新阶段）"}},[t._v("#")]),t._v(" Update（更新阶段）")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("getDerivedStateFromProps()\t根据当前的props来更新组件的state，每个render都会调用此方法\nshouldComponentUpdate()\t组件接收新的props或state时调用return true就会更新dom，return false就能阻止更新，主要用于性能优化(部分更新)\ngetSnapshotBeforeUpdate()\t在元素被渲染并写入DOM之前调用，使组件能在发生更改之前从DOM中捕获一些信息\nrender()\t重新挂载(渲染)组件\ncomponentDidUpdate()\t会在更新dom已经更新时被调用，首次渲染不会执行此方法\n")])])]),a("h3",{attrs:{id:"unmount（卸载阶段）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#unmount（卸载阶段）"}},[t._v("#")]),t._v(" Unmount（卸载阶段）")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("componentWillUnmount()\t当组件要从界面上移除的时候，首次渲染不会执行此方法\n")])])]),a("h3",{attrs:{id:"react-使用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-使用场景"}},[t._v("#")]),t._v(" React 使用场景")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("逻辑复杂单页应用，偏中后台管理系统，纯展示性的UI页面不合适\n")])])]),a("h3",{attrs:{id:"当组件的setstate函数被调用之后，发生了什么？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#当组件的setstate函数被调用之后，发生了什么？"}},[t._v("#")]),t._v(" 当组件的setState函数被调用之后，发生了什么？")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("React会做的第一件事就是把你传递给setState的参数对象合并到组件原先的state。这个事件会导致一个“reconciliation”（调和）的过程。reconciliation的最终目标就是，\n\n尽可能以最高效的方法，去基于新的state来更新UI。\n\n为了达到这个目的，React会构建一个React元素树（你可以把这个想象成一个表示UI的一个对象）。一旦这个树构建完毕，\n\n React为了根据新的state去决定UI要怎么进行改变，它会找出这棵新树和旧树的不同之处。React能够相对精确地找出哪些位置发生了改变以及如何发生了什么变化，\n\n并且知道如何只通过必要的更新来最小化重渲染\n")])])])])}],!1,null,null,null);a.default=r.exports}}]);